---
layout: post
title: 记一次大公司笔试
date: 2020-9-30
categories: 前端
tags: [前端开发,笔试]
---
## 前言

&emsp;&emsp;第一次做大公司的笔试题，确实感觉自己的水平还有待提高，但也挺庆幸在这个时候知道自己该往哪个方向学习。谈谈感受：选择题非常简单，就是考察html，css的使用，让我比较困惑的是竟然没考js相关操作。问答题第一题是同源策略，虽然我知道它的含义但是感觉说的确实比较肤浅，还是需要继续充电；第二题是cookie的弊端，我脑子里只有？但是没办法不知道也得写，就写了个数据存储在本地有安全隐患；第三题是谈谈前端优化，老实说，我根本没想过优化，只要实现需求就行，但是浅显的优化还是写了一些；另外两题cookie和...(忘记怎么拼了)的区别、浏览器本地存储就随便写了。编程题就是一些简单的算法，虽然简单，但是没刷题还是有点困难，我还以为会考些前端相关的编程(防抖，节流，闭包，异步编程...)，但没想到全是些应用题。
<br/>
&emsp;&emsp;事后还是查了些资料，把相关知识奉上。

## 同源策略

#### 概念:

浏览器安全的基石是“同源政策”（same-origin policy）“，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是”三个相同“。

#### 为什么要有同源限制？

为了保证用户信息的安全，防止恶意的网站窃取数据。<br/>
举例说明：比如一个黑客程序，他利用IFrame把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这
样用户名，密码就轻松到手了。

#### 非同源限制

* 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
* 无法接触非同源网页的 DOM。
* 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

#### 同源条件：同协议，同域名和同端口

#### 跨源通信方法：

同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个同源政策。
* JSONP
JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务端改造非常小。

JSONP的基本思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。

首先，网页动态插入<script>元素，由它向跨源网址发出请求。

```
function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute("type","text/javascript");
  script.src = src;
  document.body.appendChild(script);
}
 
window.onload = function () {
  addScriptTag('http://example.com/ip?callback=foo');
}
 
function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
```

接着，服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。

```
foo({
  "ip": "8.8.8.8"
});
```

由于<script>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。

* WebSocket
WebSocket 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

* CORS
CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发GET请求，CORS 允许任何类型的请求。

cors详细介绍见：http://javascript.ruanyifeng.com/bom/cors.html

## 前端优化

前端优化的途径有很多，可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。

#### 一、页面级优化

1. 减少 HTTP请求数
(1). 从设计实现层面简化页面　　如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。
(2). 合理设置 HTTP缓存　　缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。　　
(3). 资源合并与压缩　　尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。　　
(4). CSS Sprites　　合并 CSS图片，减少请求数的又一个好办法。　　
(5). Inline Images　　使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。　
(6). Lazy Load Images　这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。
2. 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
3. 异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)
4. Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）
5. 将 CSS放在 HEAD中
6. 异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）

#### 二、代码级优化

1. Javascript　　
(1). DOM　　
 DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。如果脚本中包含了大量的 DOM操作则需要注意以下几点：　　
 HTML Collection（HTML收集器，返回的是一个数组内容信息）　　在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性。当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。
(2). 慎用 with   
(3). 避免使用 eval和 Function　　每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。使用 eval和 Function也不利于Javascript 压缩工具执行压缩。　　(4). 减少作用域链查找
低效率的写法：

```
// 全局变量 var globalVar = 1;
 function myCallback(info)
 { for( var i = 100000; i--;)
 { //每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次       globalVar += i;    
 }} 　　
```

更高效的写法：

```
// 全局变量 var globalVar = 1;
 function myCallback(info)
 {    //局部变量缓存全局变量    
  var localVar = globalVar;    
  for( var i = 100000; i--;)
  {  //访问局部变量是最快的    
      localVar += i;    
  }   
 //本例中只需要访问 2次全局变量在函数中只需要将 globalVar中内容的值赋给localVar 中区  
  globalVar = localVar; 
 }　
```
(5). 数据访问　　Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。
(6). 字符串拼接　　
在 Javascript中使用"+" 号来拼接字符串效率是比较低的，高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。

## cookie

#### cookie含义

由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。

　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

#### cookie利弊

* 优点：极高的扩展性和可用性

1. 通过良好的编程，控制保存在cookie中的session对象的大小。
2. 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
3. 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
4. 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。

* 缺点：

1. `Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。
2. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。
3. 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
