---
layout: post
title: JS防抖和节流
date: 2020-10-3
categories: 前端
tags: [前端开发,防抖,节流,前端学习]
description: JS防抖和节流区别和实现
---
## 一.前言

#### 在前端开发过程中，经常绑定持续触发的事件 (比如 resize、scroll、mousemove)，但我们不希望在事件触发的太过频繁 (比如滚动事件频繁调用回调函数很可能会造成页面的卡顿)，那么如何降低触发频率？

* 一种做法就是在回调函数里添加延时函数，但这不值得提倡因为这会给系统加大负担，降低了网页运行速度，并且很多时候无法满足需求
* 另一种做法就是通过函数实现，JS称之为 debounce（防抖）和 throttle（节流）

<br/>

## 二.区别

* 防抖动:触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，执行时间清零n=0(和嵌入式开发的防抖没有区别，理论上可以只触发一次，只要一直触发事件)
* 节流:多次执行变成每隔一段时间执行(真正的降低执行频率)

<br/>

## 三.防抖 

```
/*
函数功能：防抖,使用闭包实现
@fun:事件触发处理函数
@time:延迟执行时间,单位毫秒
*/
function debounce(fun,time) {
    let timeout = null; // 存放定时器
    return function () {
        // 每当触发事件时清除前一个 setTimeout
        clearTimeout(timeout); 
        // 创建一个新的 setTimeout,函数对象arguments：保存函数参数，this指向当前函数
        timeout = setTimeout(() => {
            fun.apply(this, arguments);
        }, time);
    };
}
```

<br/>

## 四.节流

```
/*
函数功能：节流,使用闭包实现
@fun:事件触发处理函数
@time:间隔执行时间,单位毫秒
*/
function throttle(fun, time) {
    let timeout;
    return function() {
        if (!timeout) {
            timeout = setTimeout(() => {
                timeout = null;
                fun.apply(this, arguments);
            }, time);
        }

    };
}
```

<br/>

## 八.关于

* 本篇博客参考了[mqyqingfeng](https://github.com/mqyqingfeng/Blog/issues/22)
* 本篇博客参考了[mqyqingfeng](https://github.com/mqyqingfeng/Blog/issues/26)