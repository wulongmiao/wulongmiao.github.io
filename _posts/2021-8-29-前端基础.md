---
layout: post
title: 前端基础
date: 2021-8-29
categories: 前端
tags: [前端开发, 基础内容]
---

## 目录

<div><a href="#algorithm" target="_self">1. 简单排序算法</a></div>
<div><a href="#webBase" target="_self">2. html,web基础</a></div>
<div><a href="#cssBase" target="_self">3. css</a></div>
<div><a href="#jsBase" target="_self">4. js</a></div>
<div><a href="#regexp" target="_self">5. 正则表达式</a></div>
<div><a href="#vueReact" target="_self">6. vue,react</a></div>

<div id="algorithm" ></div>

## 简单排序算法

<img src="/img/排序算法.png">

- 冒泡：重复遍历,比较两个元素,判断是否需要交换
  选择：在待排序序列中找到最值,放入排序序列起始位置,再从未排序列中找最值,直至待排序列为空。改进可以选出每轮最大和最小
- 堆排序(交换)：每个节点都大于子节点的值(大堆),小于则是小堆,交换堆顶和末尾元素重新建堆

- 快速(冒泡改进)：选定一个元素,将大于这个元素,和小于这个元素分别放入两个序列中,在两个序列中按照这个规则排序

- 归并：分为两个长度一样的序列,递归排序,最后和并
- 插入：每一步都将元素插入到排好序的序列中适当位置,直至全部插入
- 希尔排序(插入)：把数据按增量分成多份,对每一份插入排序,增量减半,直到增量 1,基本有序,执行插入排序完成

#### 代码

```
//冒泡
	for (int i = 0; i < len - 1; ++i)
	{
		bool exchange = false;
		for (int j = 1; j < len - i; ++j)
		{
			if (arr[j - 1]>arr[j])
			{
				swap(arr[j-1],arr[j]);
				exchange = true;
			}
		}
		if (exchange == false)
		{
			return;
		}
	}


//选择
	for (int i = 0; i < len-1; ++i)
	{
		int k = i;//k保存最小的数
		for (int j =i+1; j < len-1; ++j)
		{
			if (arr[k]>arr[j])
			{
				k=j;
			}
		}
		if (k != i)
		{
			swap(arr[k], arr[i]);
		}
	}


//插入
for(let i=0;i<len;i++){
let key=data[i]; //待插数据
let j=i-1;
while(j>=0 && data[j]>key){
data[j+1]=data[i];
j--;
}
data[j+1]=key;
}

//归并排序
function quickSort(arr) {

if (arr.length < 2) return arr

let baseIndex = Math.floor(arr.length / 2);

let base = arr.splice(baseIndex, 1)[0];

let left = [];

let right = [];

for (let i = 0; i < arr.length; i++){

  if (arr[i] < base) {

    left.push(arr[i]);

  } else {

    right.push(arr[i]);

  }

}

return quickSort(left).concat([base], quickSort(right));

}


// 快排 小到大
function quickSort(arr,left,right) {
if(left>right) return
let l=left,r=right,baseValue=arr[l]
while (l<r) {
    while (l<r && arr[r]>=baseValue) {
        r--
    }
    while (l<r && arr[l]<=baseValue) {
        l++
    }
    if(l<r){
        let temp = arr[r]
        arr[r] = arr[l]
        arr[l] = temp
    }
}
arr[left] = arr[l]
arr[l] = baseValue
quickSort(arr,l+1,right)
quickSort(arr,left,l-1)
return arr
}
```

- - -

<div id="webBase" ></div>

## html,web 基础

HTMl 常用转义字符

```
space空格           &nbsp;
半个中文空格	    &ensp;
中文空格	            &emsp;
<                   &lt;
>	                &gt;
&	         &amp;
" 	         &quot;
'	         &apos;
©	         &copy;
```

js 转义字符

```
\n      换行
\t      tab
\r      回车符
\\      反斜杠
\u         unicode编码
```

meta

```
name属性主要用于描述网页,对应属性是 content ,以便于搜索引擎机器人查找、分类

A. keywords(关键字)
说明：用于告诉搜索引擎,你网页的关键字

B. description(网站内容的描述)
说明：用于告诉搜索引擎,你网站的主要内容

C. viewport(移动端的窗口)
<meta name="viewport" content="width=device-width, initial-scale=1">

D. robots(定义搜索引擎爬虫的索引方式)
说明：robots用来告诉爬虫哪些页面需要索引,哪些页面不需要索引。
具体参数如下：
1.none : 搜索引擎将忽略此网页,等价于noindex,nofollow。
2.noindex : 搜索引擎不索引此网页。
3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。
4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引,等价于index,follow。
5.index : 搜索引擎索引此网页。
6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。

E. author(作者)
说明：用于标注网页作者

F. generator(网页制作软件)
说明：用于标明网页是什么软件做的

G. copyright(版权)
说明：用于标注版权信息

H. revisit-after(搜索引擎爬虫重访时间)
说明：减轻搜索引擎爬虫对服务器带来的压力,设置爬虫的重访时间



http-equiv类似于HTTP的头部协议,它回应给浏览器一些有用的信息,网页内容。与之对应的属性值为content

A. content-Type(设定网页字符集)(推荐使用HTML5的方式)
说明：用于设定网页字符集,便于浏览器解析与渲染页面
<meta http-equiv="content-Type" content="text/html;charset=utf-8">  //旧的HTML,不推荐
<meta charset="utf-8"> //HTML5设定网页字符集的方式,推荐使用UTF-8

B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)
说明：用于告知浏览器以何种版本来渲染页面。
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/> //指定IE和Chrome使用最新版本渲染当前页面

C. cache-control(指定请求和响应遵循的缓存机制)
<meta http-equiv="cache-control" content="no-cache">
共有以下几种用法：
no-cache: 先发送请求,与服务器确认该资源是否被更改,如果未被更改,则使用缓存。
no-store: 不允许缓存,每次都要去服务器上,下载完整的响应。（安全措施）
public : 缓存所有响应,但并非必须。因为max-age也可以做到相同效果
private : 只为单个用户缓存,因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）
maxage : 表示当前请求开始,该响应在多久内能被缓存和重用,而不去服务器重新请求

D. expires(网页到期时间)
说明:用于设定网页的到期时间,过期后网页必须到服务器上重新传输。
<meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" />

E. refresh(自动刷新并指向某页面)
说明：网页将在设定的时间内,自动刷新并调向设定的网址。
<meta http-equiv="refresh" content="2;URL=http://www.lxxyx.win/"> //意思是2秒后跳转向我的博客

F. Set-Cookie(cookie设定)
说明：如果网页过期。那么这个网页存在本地的cookies也会被自动删除。
```

Unicode 编码

```
万国码：全世界所有的语言、公式、符号
编码范围：0x000000-0x10FFFF  3个字节——24位
UTF-8：通过规则转换后再存储,变字长编码,前0x7f字符与ASCII码兼容
UTF-16：2字节存储,js字符串编码方式
	UTF-16BE大端就是将高位的字节放在低地址表示
	UTF-16LE小端就是将高位的字节放在高地址表示
UTF-32：使用4个字节存储,直接存码值,很多情况下是浪费内存的

ES6用\u表示unicode-32编码
```

cookie,session,localStorage 区别

```
为了弥补http/https协议无状态(不知道上次浏览器的操作)的缺陷,增加本地缓存

cookie 第一次请求后,后端响应头设置cooKie,以后作为HTTP请求响应头的一部分,
自定义保存时间,长度和数量的限制4k
sessionstorage 浏览器关闭删除数据5m,安全性高些,不用担心被截取
localStorage 除非用户删除数据5m,否则会一直存在本地,不用担心被截取
session 数据保存在服务器,安全性高,对服务器性能要求更高
```

前端性能优化方法

```
减少http请求(合并http请求,不能充分利用缓存,更新频繁不适合,会频繁更新缓存标识)
    压缩图片 懒加载 合并压缩css和js
    利用缓存精简请求(客户端)
减少域名数,cdn加速
充分利用缓存,强缓存,协商缓存
css放在head js放在底部
代码优化:减少对doM的添加,删除操作;多情况判断用hash表代替ifelse;避免全局查找;利用垃圾回收,频繁回收的对象用对象池管理(其他自动回收的高级语言)
```

http1,2,3

```
http1
队头阻塞(高延迟),并发请求限制4-8,一个请求被阻塞时，在后面排所有请求也被阻塞
无状态(无cookie,上一次请求验证了用户名密码,下一次请求服务器不知道有何关联)
明文传输

http2 谷歌SPDY
多路复用,无并发限制,只要带宽足够(请求阻塞时,请求优先级高的先被处理)
cookie
支持加密tls/ssl(https)
head头压缩,请求和响应只发送差异部分
服务端推送，让服务端主动把资源文件推送给客户端。当然客户端也有权利选择是否接收。

事实上的http2==https,各大浏览器厂商只支持经加密的http2
(丢包情况严重,速度还不如http1,丢包重传机制)

http3 谷歌quic
基于udp,解决了丢包阻塞
拥塞控制,数据包重传
```

浏览器输入 url 后发生了什么（HTTP 请求过程）

```
DNS域名解析
客户机提出域名解析请求,请求发送给本地的域名服务器。
本地域名服务器查询本地的缓存,如果有该纪录项,本地的域名服务器就直接把查询的结果返回。
如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,根域名服务器再返回给本地域名服务器一个查询域(根的子域) 的主域名服务器的地址。
本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址。
本地域名服务器把返回的结果保存到缓存,结果返回给客户机。

根据IP建立TCP连接（三次握手）

发起HTTP请求
请求行(描述客户端的请求方式,url和http协议的版本号)
请求头(referer,origin,cookie,connection,accept,authorizaiton,cache-control,xif-modified-since,host,warning,user-agent,content-type,date)
请求正文/数据(post请求,需要传递的数据传递到这)
简单请求：
head   仅请求响应首部
get 通过url传递,所以传输数据小1024,安全性低,仅查询,不做修改     常用于请求一个资源
post 安全,没有传输限制,可修改   提交表单
非简单请求：
delete 删除
put 更新

服务器处理请求,浏览器接收HTTP响应
状态行(协议版本,状态码200,状态码描述ok)
响应头(响应数据的类型,长度,编码,压缩格式,语言,服务器信息,缓存控制)
响应数据/正文(html)

渲染页面：
浏览器将获取的HTML文档并解析成DOM树。
css构成层叠样式表模型CSSOM(CSS Object Model)
将DOM和CSSOM合并为渲染树(rendering tree)
浏览器布局 绘制页面

关闭TCP连接（四次挥手）
```

xss攻击(跨站脚本攻击)

```
注入恶意代码到网页,用户加载并执行
危害：盗用cookie
预防：
      过滤html,js,css标签,前后端转义& < > / ' "
      尽量避免.innerHTML、.outerHTML、document.write()
      dom内联事件,定时器,<a>不拼接不可信数据
       后端设置http-only-cookie
```

csrf攻击(跨站请求伪造攻击)

```
受害者登录a.com,并保留了登录凭证（Cookie）。
攻击者引诱受害者访问了b.com。
b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会…
a.com接收到请求后,对请求进行验证,并确认是受害者的凭证,误以为是受害者自己发送的请求。
a.com以受害者的名义执行了act=xx。
攻击完成,攻击者在受害者不知情的情况下,冒充受害者,让a.com执行了自己定义的操作。
常见攻击方式: img,一个自动提交的表单,链接类型

预防：
    后端生成验证码,向手机发送验证码,后端再做一次验证
    验证请求头referer,Origin字段: 只能防御跨域请求,对于攻击者本域有权限,无法防范
    验证token(服务器生成由随机字符串,时间戳组合的token传给前端,并在后端session存储token,前端每次请求时把token传回,后端验证是否被篡改)
    双重cookie(后端生成token放入cookie,请求时提交一个cookie的值加入url参数或者放入请求头authorization,csrf无法获得具体的cookie值)
```

sql注入攻击
```
利用程序漏洞,sql拼接,执行恶意代码(获取,篡改数据库数据)
防范：数据类型,格式检查;数据过滤
```

ddos攻击
```
短时间内发起大量请求,耗尽服务器的资源,无法响应正常的访问
防范：请求过滤
```

同源策略

```
仅同域名,同端口,同协议的网页可以通讯,无法读取非同源网页的 Cookie、LocalStorage,无法向非同源地址发送 AJAX 请求
```

- - -

<div id="cssBase"></div>

## css

dom 对象宽高

```
只读属性
可视区域paddding+content：clientHeight clientWidth
padding+content+boder:offsetHeight offsetWidth
offsetParent:最近的父元素
offsetTop offsetLeft：与最近父元素的top left
scrollHeight scrollWidth:元素宽高,包括卷起的内容,若无=client

可写属性
scrollTop scrollLeft:当前区域卷起的宽高left,top
```

css 编写顺序

```
定位属性
自身属性
文本属性
其他属性
```

前端布局

```
静态布局
    网页外层容器有固定的大小,所有的内容以该容器为标准,超出宽高的部分用滚动条


自适应布局
	屏幕大小改变时,会出现不同的布局,由多个静态布局组成,只改变位置,大小不变


流式布局
	随着屏幕的改变,页面的布局没有发生大的变化,可以进行适配调整,这个正好与自适应布局
相补,元素的大小会变化而位置不会变化

1.两列布局
 两列布局是一侧固定,另一侧自适应。一般一个浮动,另一个设置margin,或者一个绝对定位,另一个设置margin

2.三列布局
   定位实现：
<div class="container">
<div class="left">left</div>
<div class="center">middle</div>
<div class="right">right</div>
</div>
	.container{
	position: relative;
	height: 100%;
}
.left,
.right{
	position: absolute;
	top: 0;
	width: 200px;
	height: 200px;
	background-color: pink;
}
.left{
	left: 0;
}
.right{
	right: 0;
}
.center{
	margin-left: 200px;
	margin-right: 200px;
	background-color: purple;
	height: 200px;
}

   浮动实现：
   <div id="left">left</div>
<div id="right">3</div>
<div id="middle">2</div>

#left,#right{
   width: 200px;
   height: 200px;
   background-color:pink;
}
#middle{
   height: 200px;
   background-color: green;
}
#left{
   float: left;
}
#right{
   float: right;
}

   圣杯布局：利用父容器的左、右内边距定位

     <div class="container">
        <div class="center">测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试</div>
        <div class="left">left</div>
        <div class="right">right</div>
    </div>
        .container{
            padding: 0 200px;
        }
        .center{
            width: 100%;
            background-color:pink;
            min-height: 200px;
            float: left;
            /* margin: 0 200px;  不能用这种方式留出左右两边空白  */
        }
        .left,
        .right{
            background-color:purple;
            width: 200px;
            height: 200px;
            float: left;
        }
        .left{
            margin-left:-100%;
            position: relative;
            left: -200px;
        }
        .right{
            margin-right: -200px;
        }


   双飞翼布局：把主列嵌套在div后利用主列的左、右外边距定位
// html,middle中增加了middle-inner
<div class="wrap">
  <div id="content">
    <div id="middle">
      <div class="middle-inner">
        middle
      </div>
    </div>
    <div id="left">left</div>
    <div id="right">right</div>
  </div>
</div>
// css
.wrap{
  min-width: 600px;
}
#left,#right{
  width: 200px;
  height: 200px;
  background-color:pink;
}
#middle{
  background-color: green;
  width: 100%;
  height:200px;
  float: left;
}
#left{
  float: left;
  margin-left: -100%;
}
#right{
  float: left;
  margin-left: -200px;
}
.middle-inner{
  margin: 0 200px;
}

//flex三列布局
<div class="box">
    <div class="left"></div>
    <div class="center"></div>
    <div class="right"></div>
</div>
.box{
    display: flex;
    height: 60px;
    width: 100%;
    background-color: red;
}
.center{
    flex: 1;
    background-color: yellow;
}
.left,.right{
    width: 60px;
    background-color: pink;
}

弹性布局 flex
容器属性
flex-flow: flex-direction flex-wrap
flex-direction(改变主轴方向,默认是水平方向,交叉轴默认垂直方向):row(默认值) column  -reverse
flex-wrap:wrap nowrap(默认值)	wrap-reverse
justify-content:flex-start(默认值) flex-end center space-around  space-between
align-items:stretch(默认值) flex-start flex-end center  baseline
align-content:多行的对齐,单行无作用 stretch(默认值) flex-start flex-end center space-around  space-between

项目属性
align-self设置具体的项目,覆盖align-items flex-start flex-end center stretch baseline

order:0->n 优先级变小

flex
flex-grow：0(默认值,不放大)  数值越大,放大
flex-shink：1(默认值,空间不足缩小)
flex-basis在分配多余空间之前,项目占据的主轴空间


响应式布局
	媒体查询,根据不同设备适配
```

两种盒子模型

```
盒子总宽高: content+padding+boder+margin
内容宽高：
  标准盒子模型： width=content   元素padding,magin,boder单独计算
  ie盒子模型： width=content+padding+boder

切换 box-sizing:content-box(默认值)  boder-box
```

csshock

```
多浏览器兼容
在css样式中加入一些特殊的符号不同浏览器势必为不同的符号(比如：_ *只有ie识别)
是一种不推荐的兼容方案
```

盒模型 display:none,visibility:hidden 和 opcatity:0 的区别

```
none：脱离文档流,不能触发事件,且不会被继承
hidden：不能触发事件,可以继承
0:可触发绑定事件,可以继承
```

行内元素,行内块元素,块元素

```
行内元素(内联元素):设置宽高无效,可以设置水平magin和垂直水平padding,
默认高宽是自身内容高宽,不能放块标签

a label span
例外：a可以放除a外的标签

行内块元素:能设置宽高,其余和行内元素相同
img input button td select textarea

块元素:独占一行,不设置宽高默认情况为父元素的宽度,高度为0
例外：p,h不能放块标签
```

margin 塌陷

```
同一个BFC的相邻box发生margin重叠
父子嵌套元素在垂直方向的margin,他们两个同方向的margin会取较大值.
正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位.
但由于margin的塌陷,当子级magin大于父级会带着一起运动
解决,父元素添加:
(创建BFC：块级格式化上下文,不受外界影响,bfc区域与float不会重合,float也能撑起bfc的高度)
(1)position:absolute/fixed(脱离文档流)
(2)display:inline-block/inline-grid/inline-table/
table-caption/table-cellflex/table/grid
(3)float:left/right(脱离文档流)
(4)overflow:hidden/auto/scroll
```

浮动(高度)塌陷 清除浮动

```
原因：在文档流中,父元素的高度默认是被子元素撑开的
子元素设置浮动无法撑起父元素的高度,且此时父元素未设置高度,导致父元素的高度塌陷
,父元素下的所有元素都会向上移动,造成布局错位

clear:both
overflow:hidden
父级元素添加高度
```

选择器优先级

```
!important
内联样式
id 选择器
伪类选择器 link hover visited :first-child:last-child  nth_child  类选择器 属性选择器[attribute]
伪元素 before after  元素(标签)选择器
关系选择器+ >  统配选择器 *
继承
默认
```

水平垂直居中

```
子元素添加：
单行文本：line-height:hegiht          text-align:center(仅块级元素)

多行文本垂直居中：
子元素：vertical-align:middle(仅行内块元素)  line-height:num
父元素：line-height:num

宽高固定,子元素添加：
	子元素宽高已知absolute;top,left:50%;   	 magin-left,magin-top:- (元素50%宽高)
	子元素宽高固定absolute;top,left,right,bottom:num(一般设置0)   magin:auto
	无限制absolute;top,left:50%; transform:translate(-50%,-50%)

移动端,父元素添加,flex
    justify-content: center;
    align-items: center;

grid
    align-self: center;
    justify-self: center;
```

<img src="/img/pos.PNG">

回流(重排)和重绘

```
回流：当render tree中尺寸,布局,隐藏等改变需要重新构建render tree。这就称为回流(reflow)。  回流必重绘
重绘：当render tree中的一些元素需要更新属性,而这些属性只是影响元素的外观,风格,而不会影响布局的
```

- - -

<div id="jsBase" ></div>

## js

JS 对象常用方法

```
date对象：getDate() getDay() getFullYear() getHours() getMinutes() getMonth()
setDate() setDay() setFullYear() setHours() setMinutes() setMonth()
Date.now() toJson() toLocalString() toLocalDateString() toLocalTimeString()

定型数组：int16Array() int32Array() float32Array() floatArray()
int8Array()  Uint8 Uint16 Uint32  of  from
数组缓冲存储数据,数组元素不能用数组普通数组方法改变

数组：fill[value,start,end) slice[) splice[第a个元素前,删除b个,添加元素]join(指定分隔符默认,)
pop() push() reverse() sort() unshift shift concat indexOf() lastIndexOf() includes() isArray()
toString()  from() filter() find() findIndex() every() some() reduceRight() reduce()
map() foreach(function(currentValue,index,arr))无返回值,速度快,可以改变原数组

字符串:split(指定分隔符 可使用正则表达式 ,指定返回数组length,满足条件返回)
match匹配值,多次匹配依赖g  padEnd(num,symbol) pandStart(num,symbol) String.fromCharCode()
 charAt(num) charCodeAt(num) indexOf() lastIndexOf()  split() includes() link() concat()
replace可匹配多个值,默认匹配一次依赖g repalceAll() search匹配单个下标,无值返回-1
trim()去除两边空字符 trimStart()去除开始的空字符 trimEnd()去除开始的空字符 trimLeft trimRight
 substr[截取下标a,获取字符b个] substring[)=slice
startWith()判断是否以指定字符串开始 endWith() repet(num)  toLowerCase()  toUpperCase()

数学：random() ceil()上舍入 floor()下舍入 round()四舍五入 pow(x,y)x的y次方 min() max() abs()

数字方法：toPrecision()返回位数 toFixed()返回小数点后指定位数 toString(num)

global：Number() String(obj) parseInt() parseFloat() isNaN() Number() eval() Infinity NaN undefined 	isFinite()
escape()编码 unescape()解码             字符串编解码,不用于url
decodeURI()解码 encodeURI()编码         编码整个url
decodeURIComponent()  encodeURIComponent()        编码范围更广,编码参数

Object:create(a,b)只能获得a本身的属性,不能读取a的原型
defineProperties(a,b)a对象上定义新的属性,或者修改现有属性
getOwnPropertyDescriptor getOwnPropertyDescriptors
Object.defineProperty(obj,name,descriptor)  hasOwnProperty()是否具有指定的属性
A.isPrototypeOf(B)B是否存在于A的原型链上	 Object.prototype.isPrototypeOf(Array)
freeze()对象永远是不可变  isFrozen()
preventExtensions()可修改,删除现有属性,不能添加新属性 isExtensible() getOwnPropertyNames()指定对象的所有自身属性的属性名组成的数组
```

window 对象

```
innerWidth innerHeight outWidth outHeight包含工具栏,滚动栏
pageXOffset pageYOffset页面左上角滚动栏卷走的px
screenX screenY screenLeft screenTop窗口相对屏幕的坐标
sessionStorage localStorage.setItem(a,b) getItem(a) removeItem(a)
confirm带有确认,取消提示框 alert prompt()可输入提示框
clearInterval clearTimeout setTimeout setInterval	open(url,name打开方式) close
getComputedStyle()仅支持读,读取样式是最终样式  getSelection()获得选中内容
matchMedia(查询字符串) .matches媒体查询 addListener(fn)经停监听媒体查询变化 	removeListener(fn)
moveBy()移动指定坐标 moveTo()  resizeBy() resizeTo() scrollBy() scrollTo()
print()打印 stop()停止加载
跨源通信otherWindow.postMessage(data, [],transfer)otherWindow其他窗口引用：
window.open窗口对象、iframe的contentWindow属性,data将要发送的数据,[]指定窗口url,transfer对象所有权转移给接收方

location:hash返回#后  host hostname返回主机和端口  href返回url search返回查询部分
assign()载入新文档 reload()重载页面 replace()替换页面,不可返回前一个页面
```

(window).document 对象

```
select()
执行一个当前文档,当前选择或者给出范围的命令execCommand("Copy")

addEventListener() removeEventListener()
anchors返回当前页面锚节点数组,必须包含name属性才会加入数组
baseURI domain返回域名  URL=location.href title cookie() lastModified最后一次修改
open() close() write() writeIn()

creatAttribute()属性节点 creatComment()注释节点 createElement()元素节点  creatDocumentFragment()虚拟对象节点
createTextNode()文本节点 getAttribute()返回属性值 getAttributeNode()返回属性节点
hasAttribute()判断存在指定属性 hasAttributes()判断存在属性 hasChildNodes()判断存在子节点
removeAttribute(name) removeAttributeNode() removeChild()
replaceChild(new,old) setAttribute(name,value) setAttributeNode()

appendChild()添加到最后的子节点 insertBefore(newNode,oldNode)添加到老节点之前
attributes属性集合 childNodes子节点(所有类型)集合 children子元素节点集合
parentNode firstChild lastChild cloneNode(true克隆子孙节点)
nextSibling返回下一个同级节点 nextElementSibling只返回元素节点
previousSibling前一个同级节点 previousElementSibling只返回元素节点
a.isEqualNode(b)ab两个节点相等 a.isSameNode(b)ab同一个节点

querySelector() querySelectorAll()用css选择器,性能更差  getElementBy()
contentEdiable  isContentEdiable nodeName className id
value属性值 innerHTML()所有节点 textContent()获取文本节点 nodeValue()对属性、注释、文本节点有效

attributes属性集合：name value length
```

ES6 新特性

```
解构赋值 let[a,b,c]=[56,56,6]
字符串扩展
	双字节	'\uxxxx'  \u0000~\uFFFF
	完整unicode	'\u{}'

数组扩展 flat(n)  ...
	from将类数组对象和可遍历对象(set,map)转为数组 of将值转化为数组  for of
    键值对遍历entries() 键名遍历keys() 键值遍历values() 返回遍历器对象Iterator

遍历器Iterator：为各种数据结构(set,map,array,object)提供统一的接口,主要供for of使用
创建指针对象,调用next指向数据结构,不能链式 返回对象{value,done}
	自定义迭代器[Symbol.iterator](){}
生成器generator: function* a(){yield}
	第一次调用next开始执行生成器,传参无效
	yield* 能迭代可迭代对象,相当于对象添加一个迭代器
	自定义生成器的迭代器 *[Symbol.iterator](){}
使用场合：解构赋值 ...  for of  array.from() promise.all() promise.race()

对象扩展 属性简写：变量写在{}里面,属性名=变量名 属性值=变量值  解构赋值{...}
		方法简写：a:function(){}  a(){}
		super只能用在对象的简写方法中,指向当前对象的原型对象中,常用于类的继承

对象新方法 Object.setPrototypeOf() getPrototypeOf()
		  Object.is(a,b) 与===不同NaN=NaN -0!=+0
		  Object.assign(a,b,c...) 对象合并 b,c...复制到a 浅拷贝,处理数组会覆盖
   		  键值对遍历entries() 键名遍历keys() 键值遍历values() 返回数组
		  fromEntries()是Object.entries([[],[]])的逆操作,用于将一个键值对数组转为对象


map([[][]]) 键名可定义为对象,不再局限于字符串 set() get() delete() has() clear() size ,也可以直接接受数组创建
set对象 类数组对象,值不可重复,自动过滤重复元素,也可以直接接受数组创建add delete clear has size
模块import from只读,对象可改 export default可不需要了解模块具体细节,默认加载,此时import可起任意名

类的方法定义在prototype,包括构造函数 set  get设置存取值函数
静态方法,属性不会被实例继承,但可以被类继承,只能直接通过类调用
私有方法和属性在前面加上#,且变量无需关键词

类的继承constructor中显示写法必须先使用super,调用super后才能用this,再用this改变指向
super作为函数使用时,super指向子类的构造函数,但代表的是父类的构造函数,只能用于构造函数
super作为对象使用时,指向父类,但this指向子类,无法调用父类的实例方法属性

父类a 子类b
b.prototype._proto_=a.prototype
b._proto_=a
因为继承实现基于setPrototypeOf=function(b.prototype,a.prototype){
b.prototype._proto_=a.prototype;
return b.prototype;
}

可继承原生构造函数boolean() array() number() string() date() function() object()

promise,async/await,generator
指数运算符**    扩展运算符...    模板字面量``   `a+${}+b`
新类型symbol('')唯一不会产生冲突
箭头函数没有原型,this指向定义时所在的对象,并且不能改变指向
const let
```

表单

```
action 属性设置提交的服务器地址
method 属性设置提交的方式 GET(默认值)或 POST

通过 submit()提交表单时,submit 事件不会触发。因此在调用这个方法前要先做数据验证。
调用 reset()方法会像单击了重置按钮一样触发 reset 事件
form.elements[num]
表单字段属性
 disabled：布尔值,表示表单字段是否禁用。
 form：指针,指向表单字段所属的表单。这个属性是只读的。
 name：字符串,这个字段的名字。
 readOnly：布尔值,表示这个字段是否只读。
 tabIndex：数值,表示这个字段在按 Tab 键时的切换顺序。
 type：字符串,表示字段类型,如"checkbox"、"radio"等。
 value：要提交给服务器的字段值。对文件输入字段来说,这个属性是只读的,仅包含计算机上
某个文件的路径。
表单字段方法
focus()  	blur()


ajax/fetch

XMLHttpRequest Level 1

let ajax = new XMLhttpRequest();
ajax.open(get/post,'url',false);
//模拟表单提交,配置请求头
//ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
ajax.send();
ajax.onreadstatechange()=function(){
if(ajax.readyState==4 && ajax.status==200)
return ajax.reponeseText;
	   ajax.reponseXML
}

XMLHttpRequest Level 2

formData()表单数据序列化
数据填充
let test=new formData().append(name,value)相当于表单字段名称和该字段的值
formData(document.form[num])

ajax.send(test);

超时
超时设置ajax.timeout=1000;
超时事件ajax.ontimeout=function()

overrideMimeType()重写XHR响应的MIME类型


进度事件

loadstart：在接收到响应的第一个字节时触发。
progress：在接收响应期间反复触发。
error：在请求出错时触发。
abort：在调用 abort()终止连接时触发。
load：在成功接收完响应时触发。  可替代readyStateChange,不用检查readyState
loadend：在通信完成时,且在 error、abort 或 load 之后触发。

安全
任何 Ajax 可以访问的 URL,也可以通过浏览器或服务器访问,csrf攻击
验证请求发送者拥有对资源的访问权限：
要求通过 SSL 访问能够被 Ajax 访问的资源。
要求每个请求都发送一个按约定算法计算好的令牌（token）(加密)。
注意,以下手段对防护 CSRF 攻击是无效的：
要求 POST 而非 GET 请求（很容易修改请求方法）。
使用来源 URL 验证来源（来源 URL 很容易伪造）。
基于 cookie 验证（同样很容易伪造）。


文本框
select()
selectionStart 		selectionEnd
setSelectionRange==slice
这两个属性包含基于 0 的数值,分别表示文本选区的起点和终点


HTMLFormElement
 acceptCharset：服务器可以接收的字符集,等价于 HTML 的 accept-charset 属性。
 action：请求的 URL,等价于 HTML 的 action 属性。
 elements：表单中所有控件的 HTMLCollection。
 enctype：请求的编码类型,等价于 HTML 的 enctype 属性。
 length：表单中控件的数量。
 method：HTTP 请求的方法类型,通常是"get"或"post",等价于 HTML 的 method 属性。
 name：表单的名字,等价于 HTML 的 name 属性。
 reset()：把表单字段重置为各自的默认值。
 submit()：提交表单。
 target：用于发送请求和接收响应的窗口的名字,等价于 HTML 的 target 属性



跨域请求
html提交表单不受同源限制,ajax提交表单受同源限制
非同源
（1） Cookie、LocalStorage 和 IndexDB 无法读取。
（2） DOM 无法获得。
（3） AJAX 请求不能发送。

<img>任何页面都可以跨域加载图片而不必担心限制:发送 GET 请求和无法获取服务器响应的内容

子域设置相同的document.domain,共享cookie,iframe
iframe.contentWindow, 获取iframe的window对象
iframe.contentDocument, 获取iframe的document对象
window.frames[name].window

postMessage()
`<iframe src="http://tuhao.com" name="sendMessage"></iframe>`

let ifr = window.frames['sendMessage'];
ifr.postmessage('send message', "http://tuhao.com");

e.source – 消息源,消息的发送窗口/iframe。
e.origin – 消息源的 URl(可能包含协议、域名和端口),用来验证数据源。
e.data – 发送过来的数据。
//接受数据
window.addEventListener('message', receiver, false);
function receiver(e) {
    if (e.origin == 'http://tuhao.com') {
        if (e.data == 'send message') {
            e.source.postMessage('receive message', e.origin);  //向原网页返回信息
        } else {
            alert(e.data);
        }
    }
}
//子窗口将父窗口发来的消息,写入自己的LocalStorage
window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') {
    return;
  }
  let payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};


CORS：用自定义的 HTTP 头部允许浏览器和服务器相互了解,以确实请求或响应成功还是失败
XMLHttpRequest 对象原生支持 CORS
跨域XHR不能使用 setRequestHeader()设置自定义头部,不能发送和接收 cookie


jsonp:只能发送get请求,不好确定 JSONP 请求是否失败,响应注入恶意代码,一般用计时器来决定是否放弃等待响应
function handleResponse(response) {
 console.log(`
 You're at IP address ${response.ip}, which is in
 ${response.city}, ${response.region_name}`);
}
//客户端请求
let script = document.createElement("script");
script.src = "http://freegeoip.net/json/?callback=handleResponse";
document.body.insertBefore(script, document.body.firstChild);


Fetch
  能够执行 XMLHttpRequest 对象的所有任务,但更容易使用,接口也更现代化,能够在
Web 工作线程等现代 Web 工具中使用,Fetch API 必须是异步

fetch(url,(init)); //get请求
自定义选项(init)
body 指定请求内容
headers 指定请求头
integrity 强制子资源完整性
method 请求方法
mode 请求模式 cors允许遵守CORS协议的跨源请求 no-cors允许不需要发送预检请求的跨源请求 same-origin不允许跨域
redirect 处理重定向方式
signal

1. 发送 JSON 数据
可以像下面这样发送简单 JSON 字符串：
let payload = JSON.stringify({
 foo: 'bar'
});
let jsonHeaders = new Headers({
 'Content-Type': 'application/json'
});
fetch('/send-me-json', {
 method: 'POST', // 发送请求体时必须使用一种 HTTP 方法
 body: payload,
 headers: jsonHeaders
});
2. 在请求体中发送参数
因为请求体支持任意字符串值,所以可以通过它发送请求参数：
let payload = 'foo=bar&baz=qux';
let paramHeaders = new Headers({
 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
});
fetch('/send-me-params', {
 method: 'POST', // 发送请求体时必须使用一种 HTTP 方法
 body: payload,
 headers: paramHeaders
});
3. 发送文件
因为请求体支持 FormData 实现,所以 fetch()也可以序列化并发送文件字段中的文件：
let imageFormData = new FormData();
let imageInput = document.querySelector("input[type='file']");
imageFormData.append('image', imageInput.files[0]);
fetch('/img-upload', {
 method: 'POST',
 body: imageFormData
});
这个 fetch()实现可以支持多个文件：
let imageFormData = new FormData();
let imageInput = document.querySelector("input[type='file'][multiple]");
for (let i = 0; i < imageInput.files.length; ++i) {
 imageFormData.append('image', imageInput.files[i]);
}
fetch('/img-upload', {
 method: 'POST',
 body: imageFormData
});
4. 加载 Blob 文件
Fetch API也能提供 Blob 类型的响应,而 Blob 又可以兼容多种浏览器 API。一种常见的做法是明确将
图片文件加载到内存,然后将其添加到 HTML图片元素。为此,可以使用响应对象上暴露的 blob()方法。
这个方法返回一个期约,解决为一个 Blob 的实例。然后,可以将这个实例传给 URL.createObjectUrl()
以生成可以添加给图片元素 src 属性的值：
const imageElement = document.querySelector('img');
fetch('my-image.png')
 .then((response) => response.blob())
 .then((blob) => {
 imageElement.src = URL.createObjectURL(blob);
 });
5. 发送跨源请求
从不同的源请求资源,响应要包含 CORS 头部才能保证浏览器收到响应。没有这些头部,跨源请求
会失败并抛出错误。
fetch('//cross-origin.com');
// TypeError: Failed to fetch
// No 'Access-Control-Allow-Origin' header is present on the requested resource.
如果代码不需要访问响应,也可以发送 no-cors 请求。此时响应的 type 属性值为 opaque,
因此无法读取响应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。
fetch('//cross-origin.com', { mode: 'no-cors' })
 .then((response) => console.log(response.type));
6. 中断请求
Fetch API 支持通过 AbortController/AbortSignal 对中断请求。调用 AbortController.
abort()会中断所有网络传输,特别适合希望停止传输大型负载的情况。中断进行中的 fetch()请求会
导致包含错误的拒绝。
let abortController = new AbortController();
fetch('wikipedia.zip', { signal: abortController.signal })
 .catch(() => console.log('aborted!');
// 10 毫秒后中断请求
setTimeout(() => abortController.abort(), 10);
// 已经中断


headers对象
与map类似,不同：初始化可以传入对象,append()支持添加多个值,键名相同不会覆盖


Request 对象
获取资源请求的接口：暴露了请求的相关信息,也暴露了使用请求体的不同方式
new Request(url,(init))  //与fetch对象init一样
克隆request对象
let r1 = new Request('https://foo.com');
let r2 = new Request(r1); //bodyUsed被标记为已使用,不能fetch
let r2 = r1.clone();	//完全相同的副本

fetch(r)   fetch()不能拿请求体用过的 Request 对象来发送请求,且request只能发送一次


创建response对象 //不代表实际的Http响应
let r = new Response(,{headers,status,statusText});
r.clone()
response对象 //读取响应对象
{
status（状态码） statusText（状态文本）  redirected（重定向）
url（请求成功完整url）	headers   body  bodyUsed  type  ok
}


对象混入
body.text():
 fetch('https://foo.com')
 .then((response) => response.text())
 .then(console.log);

 body.json():
 fetch('https://foo.com/foo.json')
 .then((response) => response.json())
 .then((data) => {
 console.log(data);});

 Body.formData():
 let myFormData = new FormData();
myFormData.append('foo', 'bar');
 fetch('https://foo.com/form-data')
 .then((response) => response.formData())
 .then((formData) => console.log(formData.get('foo'));



web Socket
Web Socket使用了自定义协议,所以 URL方案（scheme）稍有变化：不能再使用 http://或 https://,
而要使用 ws://和 wss://  服务器端可以主动推送信息
必须给 WebSocket 构造函数传入一个绝对 URL。同源策略不适用于 Web Socket,因此可以打开到任意站点的连接
readyState
 WebSocket.OPENING（0）：连接正在建立。
 WebSocket.OPEN（1）：连接已经建立。
 WebSocket.CLOSING（2）：连接正在关闭。
 WebSocket.CLOSE（3）：连接已经关闭。

message:服务器向客户端发送消息触发
open：在连接成功建立时触发。
error：在发生错误时触发。连接无法存续。
close：在连接关闭时触发。
WebSocket 对象不支持 DOM Level 2 事件监听器,因此需要使用 DOM Level 0 风格的事件处理程
序来监听这些事件

let socket = new WebSocket("ws://www.example.com/server.php");
socket.close(); //调用 close()之后,readyState 立即变为 2（连接正在关闭）
let stringData = "Hello world!";
let arrayBufferData = Uint8Array.from(['f', 'o', 'o']);
let blobData = new Blob(['f', 'o', 'o']);
socket.send(stringData);
socket.send(arrayBufferData.buffer);
socket.send(blobData);
//服务器向客户端发送消息时,WebSocket 对象上会触发 message 事件
socket.onmessage = function(event) {
 let data = event.data;
 // 对数据执行某些操作
};
```

闭包,内存泄漏

```
立即执行函数(function(a,b){}(传递的参数1,2,3...))

访问函数内部变量
利用垃圾回收机制,被引用的变量不会被回收,所以会造成内存泄漏
```

作用域链,变量提升

```
变量提升优先级小于函数提升
每次进入一个新的执行环境,都会创建一个用于搜索变量和函数的作用域链,搜索是一级一级往上搜索,一旦找到不再搜索
变量提升：使用了在下面定义的变量,把变量提升到函数顶部,但使用时变量值为undefined
函数提升:和变量提升类似,但是只有声明会被提升,函数表达式,构造不会被提升
```

js 多线程 通信协议

```
new Worker(js file path)
只把耗时的操作写到worker线程里

http三次握手,只能由客户端发起,做不到主动推送信息

HTML5 WebSocket：HTML5 开始提供的全双工通讯的协议,握手阶段采用http协议,无同源限制
WebSocket 使得客户端和服务器之间的数据交换变得更加简单,允许服务端主动向客户端推送数据
new WebSocket(url, [protocol] )
```

js 事件循环机制,宏任务微任务

```
事件循环：
（1）同步任务在主线程上执行,形成一个执行栈（execution context stack）。
（2）子线程(任务队列)执行异步任务。异步任务(定时器,事件)按顺序放入"任务队列"中。
（3）一旦"执行栈"中的所有同步任务执行完毕,系统就会读取"任务队列"。
（4）述过程会不断重复,也就是常说的Event Loop(事件循环)
宏任务：每次执行栈执行的代码就是一个宏任务,所有宏任务都是添加到任务队列,所以”任务队列又叫宏任务队列”,
这个任务队列由事件触发线程来单独维护的。  script,settimeout,setinterval,
setImmediate,requestAnimationFrame
微任务：当前宏任务执行结束后立即执行的任务。 promise,async/await,MutationObserver
process.nextTick(node.js)：在当前任务队列执行完,第一个执行,优先级高的异步任务
```

js 执行顺序

```
同步任务（第一个宏任务）
微任务
执行宏任务(任务队列)中的微任务
```

解决回调地狱

```
promise  pending fullfilled rejected 状态不可逆
new Promise(function(resolve,reject)),reject(),resolve()状态改变,
会继续执行后续代码,代码不会直接结束(加上return结束,后续操作放入then) then(resolve,reject)返回新的pomise实例,参数为上层promise对象返回值
catch=then(null,reject)
finally不管是什么状态都要执行,一般放在链式的最后,且不接受任何参数

Promise.all([]) 参数必须有iterator接口,参数全部resolve新实例状态变为fullfilled,参数实例返回值组成的数组传给回调,
或者第一个rejected新实例变为rejected,第一个reject参数实例的返回值传给回调
Promise.any 第一个resolve的实例返回值,或者所有参数rejected实例返回值组成的数组

Promise.race 第一个fullfilled或者rejected的实例,作为新实例的状态和返回值
Promise.allsettled 所有参数实例状态都改变才执行回调,并且新实例状态总是fullfilled,
回调接收参数是参数实例返回值（对象,包括状态属性,返回值属性）组成的数组

Promise.reject("a")=new Promise((resolve,reject)=>reject('a'));
Promise.resolve("a")=new Promise(resolve=>resolve('a'));

async/ await
awiat后面非promise对象基本等于同步操作(先执行async外部的同步代码,再执行内部代码)

任意一个状态变成reject,后续代码不再执行 await	Promise.reject
解决方案
try {
await}
catch{}
```

原型链

```
指向原型__proto__ 指向原型构造函数constructor 指向函数原型对象prototype
在JavaScript中通过__proto__ 指向prototype,直到指向Object对象为止,就形成了一个原型指向的链条,称之为原型链。
当我们访问对象的一个属性或方法时,它会先在对象自身中寻找,没有则会去原型对象中寻找,
直到找到Object对象的原型,如果在Object原型(null)中依然没有找到,则返回undefined。
```

<img src="/img/原型链.PNG">

对象继承方法

```
原型继承：不能多继承
构造函数继承call/apply:只能继承父类实例的方法,不能继承原型方法
组合继承：原型加构造继承,最常用,生成了两份实例
寄生组合继承:执行效率最高,应用面最广,实现复杂
es6的extends继承
```

bind,call,apply 的区别

```
第一个参数都是this的指向对象
bind 返回值是函数,参数和call类似
call
apply 参数是数组

```

模块化

```
模块化就是一种解决问题的方案,一个模块实现特定功能的文件

引入js脚本太多,重名,变量污染,可能存在依赖关系,需要按顺序加载
1.闭包和命名空间
2.CommonJs(服务器):require引入指定模块,module暴露内容
3.AMD和RequireJS(浏览器)
4.CMD和SeaJs
5.es6模块化：
	 export 变量名
     import * as(重命名) from src
```

防抖节流

```
用户操作会导致频繁触发事件,对dom操作,资源加载等,导致网页卡顿甚至崩溃
绑定触发高频率的事件,scroll,mousemove,resize,mousedown,keyup,希望降低触发频率
防抖：事件在n秒内执行一次,如果单位时间内又触发了事件,时间计数清零
    实时搜索,拖拽,窗口调整,页面滚动

节流：每隔n秒执行一次函数
    窗口调整,页面滚动,疯狂点击

```

深浅拷贝

```
浅拷贝：拷贝多份非数字型数据,改变一份数据,会同时改变其他数据
深拷贝：改变数据,不改变其他数据
实现:JSON.parse(JSON.stringify(obj,funciton,添加缩进))   递归   forEach
for in会迭代原型链的属性
数组返回数组下标(键值)
适合对象

for of ES6新特性,只会迭代对象本身的属性
返回数组元素
适合数组
用于对象需要
Object.key(arr)(键值)
Object.values(arr)(对象值)

```

dom0 级事件 dom2 级事件

```
0级：同一个元素绑定多个事件,只会绑定最后一个事件,只能在事件冒泡阶段触发
不支持冒泡的事件load unload scroll resize blur focus mouseleave mouseenter
取消冒泡：stopPropagation() cancelBuble=true
绑定事件：dom.onclick
解除绑定：dom.onclick=null

2级：可以监听多个事件,只有2级DOM有完整的事件流
绑定：dom.addEventListener(type,function,false)
解除绑定:dom.removeEventListener(type,function,false)
true：捕获阶段调用;false：冒泡阶段调用
```

事件流

```
接收事件的顺序,分为三个阶段
事件捕获阶段(从父元素传递到子元素)
处于目标阶段(绑定事件的那个元素)
事件冒泡阶段(子元素传递到父元素)
```

typeof 和 instance of

```
基本数据类型：number,string,null,undefined,boolean(存放在栈内存中)
引用类型存放在堆内存中,实际上存放的是指向对象的地址
基本类型：number、boolean、string、object、null、undefined,symbol
typeof：只能表示7种类型 number、boolean、string、function、object(null返回值)、undefined,symbol
instance of：检测某个对象是不是另一个对象的实例,能判断object子类
```

- - -

<div id='regexp'></div>

## 正则表达式

search match replace split

```
exec 检索字符串中指定的值,返回值,确定匹配位置
test 返回true false

优先级：\ > 圆括号和方括号 > 限定符 > 其他字符
修饰符: g全局 i忽略大小写 m多行匹配^$能匹配\n   s使.能匹配\n

匹配单个普通字符：
[ABC] 匹配括号内字符
[^ABC] 仅不匹配括号内字符
[A-Z] 匹配括号内区间的字符
\w  匹配合法变量字符(字母,数字,下划线,但不包括$)
\W  ^\w

匹配特殊字符：
除[]外都可以用[string]匹配
\[   \]

匹配非打印字符：

\f 匹配换页符
\t 匹配制表符
\r 匹配回车符
\n 匹配换行符
\\ 匹配反斜杠
\s 匹配空白字符
\S 匹配非空白字符

匹配限定符：
* 匹配前面的表达式0 || n, ==={0,}      贪婪匹配
+ 匹配前面的表达式1 || n, ==={1,}      贪婪匹配
? 匹配前面的表达式0 || 1, ==={0,1}
{n} 匹配确定的n次
{n,} 至少匹配n次     贪婪匹配
{n,m} 匹配[n,m]次

定位符：
^ 匹配输入字符串开始的位置
$ 匹配输入字符串结尾的位置

元字符：
. 任意字符
\s 匹配任何空格字符 === [ \f\n\r\t\v]
\S 匹配任何空格字符 ===  [^ \f\n\r\t\v]
\b 匹配单词边界 'er\b' 可以匹配"never" 中的 'er',但不能匹配 "verb" 中的 'er'
\B 匹配非单词边界 'er\B' 能匹配 "verb" 中的 'er',但不能匹配 "never" 中的 'er'
| 或者
(?:) 匹配 pattern 但不获取匹配结果,经常用来代替| 'industr(?:y|ies) 就是一个比 'industry|industries'
(?:) 匹配表达式 但不获取匹配结果
(?=) exp1(?=exp2)：查找 exp2 前面的 exp1
(?!)  exp1(?!exp2)：查找后面不是 exp2 的 exp1
(?<=) (?<=exp2)exp1：查找 exp2 后面的 exp1
(?<!) (?<!exp2)exp1：查找前面不是 exp2 的 exp1
```

- - -

<div id='vueReact'></div>

## vue,react

#### 虚拟DOM

避免频繁操作DOM

跨平台渲染，服务器渲染 、小程序、原生应用都使用了虚拟DOM

虚拟 DOM 可以维护程序的状态，跟踪上一次的状态
```
<ul id="list">
    <li class="item">哈哈</li>
    <li class="item">呵呵</li>
    <li class="item">嘿嘿</li>
</ul>

let oldVDOM = { // 旧虚拟DOM
        tagName: 'ul', // 标签名
        props: { // 标签属性
            id: 'list'
        },
        children: [ // 标签子节点
            {
                tagName: 'li', props: { class: 'item' }, children: ['哈哈']
            },
            {
                tagName: 'li', props: { class: 'item' }, children: ['呵呵']
            },
            {
                tagName: 'li', props: { class: 'item' }, children: ['嘿嘿']
            },
        ]
    }

```

#### vue2 diff算法

对比虚拟dom,找出更改的虚拟dom,只更新修改虚拟dom对应的真实dom,边更新边修改

实现：整体广度优先算法,同层进行比较(跨层级的位置变化,创建节点和删除节点的操作),同层遍历按照深度优先算法比较。

1.sameNode:对比当前同层的虚拟节点是否为相同节点(通过标签名,key判断),不同直接替换replace

2.相同patchVnode：
```
1.newNode有子节点,old没有,将new添加到dom;
2.old有,new无,删除真实dom子节点;
3.都有文本节点,dom文本节点设置成new的文本节点;
4.都有子节点,双指针比对节点,头节点相同;向后移,尾节点相同,向前移;头尾节点相同,插入位置;不同查找旧节点是否存在新节点的key(是否可复用),存在移动旧节点位置,不存在新增,循环(对比)结束裁剪old多余节点
```

源码
```
function vue2diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    newStartIndex = 0,
    oldStartIndex = prevChildren.length - 1,
    newStartIndex = nextChildren.length - 1,
    oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldStartIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newStartIndex];
  while (oldStartIndex <= oldStartIndex && newStartIndex <= newStartIndex) {
    if (oldStartNode === undefined) {
      oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefined) {
      oldEndNode = prevChildren[--oldStartIndex]
    } else if (oldStartNode.key === newStartNode.key) {
      patch(oldStartNode, newStartNode, parent)

      oldStartIndex++
      newStartIndex++
      oldStartNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newEndNode.key) {
      patch(oldEndNode, newEndNode, parent)

      oldStartIndex--
      newStartIndex--
      oldEndNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)
      oldStartIndex++
      newStartIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      oldStartIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else {
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child && (child.key === newKey));
      if (oldIndex === -1) {
        mount(newStartNode, parent, oldStartNode.el)
      } else {
        let prevNode = prevChildren[oldIndex]
        patch(prevNode, newStartNode, parent)
        parent.insertBefore(prevNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartIndex++
      newStartNode = nextChildren[newStartIndex]
    }
  }
  if (newStartIndex > newStartIndex) {
    while (oldStartIndex <= oldStartIndex) {
      if (!prevChildren[oldStartIndex]) {
        oldStartIndex++
        continue
      }
      parent.removeChild(prevChildren[oldStartIndex++].el)
    }
  } else if (oldStartIndex > oldStartIndex) {
    while (newStartIndex <= newStartIndex) {
      mount(nextChildren[newStartIndex++], parent, oldStartNode.el)
    }
  }
}
```

#### vue3 diff算法

1.前置后置预处理,头尾可复用节点直接更新

2.保存new剩余未处理节点,生成对应长度数组初始化-1,根据new保存old节点下标,找出数组最长递增子序列(递增法,如果是递增的说明位置不变),遍历数组,此时数组非-1即可复用节点,如果在子序列中old节点位置不变,-1插入节点

```
例子：
老的 children：[ a, b, c, d, e, f, g ]
新的 children：[ a, b, f, c, d, e, h, g ]
预处理后节点：[ f, c, d, e, h ]
arr: [-1,-1,-1,-1,-1]
改变arr:[ 5, 2, 3, 4, -1 ]
最长递增子序列：[2,3,4]
类似vue2对比流程
```


#### react diff算法(递增法)

1.跨层级的位置变化,则是创建节点和删除节点的操作

2.对比当前同层的虚拟节点是否为同一种类型的标签patch,不同直接替换replace

3.同层级节点：
```
先遍历new节点,找到new在old的位置,对比现在的位置,if(new=old)不需要移动,否则需要移动位置
定义标记变量,在old中找到和new相同的key,则可复用不需要插入old
移动,插入操作完成后,遍历old,把多余的old移除
```

源码
```
function reactDiff(prevChildren, nextChildren, parent) {
    let lastIndex = 0
    for (let i = 0; i < nextChildren.length; i++) {
        let nextChild = nextChildren[i],
            find = false;
        for (let j = 0; j < prevChildren.length; j++) {
            let prevChild = prevChildren[j]
            if (nextChild.key === prevChild.key) {
                find = true
                patch(prevChild, nextChild, parent)
                if (j < lastIndex) {
                    // 移动到前一个节点的后面
                    let refNode = nextChildren[i - 1].el.nextSibling;
                    parent.insertBefore(nextChild.el, refNode)
                } else {
                    // 不需要移动节点,记录当前位置,与之后的节点进行对比
                    lastIndex = j
                }
                break
            }
        }
        if (!find) {
            // 插入新节点
            let refNode = i <= 0
                            ? prevChildren[0].el
                            : nextChildren[i - 1].el.nextSibling
            mount(nextChild, parent, refNode);
        }
    }
    for (let i = 0; i < prevChildren.length; i++) {
        let prevChild = prevChildren[i],
            key = prevChild.key,
            has = nextChildren.find(item => item.key === key);
        if (!has) parent.removeChild(prevChild.el)
    }
}
```