---
layout: post
title: 前端面试
date:  2020-10-18
categories: 前端
tags: [前端开发,面试]
---
## 目录

<div><a href="#sjjg" target="_self">1. 算法</a></div>
<div><a href="#web" target="_self">2. html，http，web基础</a></div>
<div><a href="#csss" target="_self">3. css</a></div>
<div><a href="#jss" target="_self">4. js</a></div>
<div><a href="#vues" target="_self">5. vuejs</a></div>
<div><a href="#hr" target="_self">6. hr面</a></div>
<div id="mianshi" ></div>

## 算法

<img src="/img/排序算法.png">

排序算法:
```
冒泡：重复遍历，比较两个元素，判断是否需要交换
选择：在待排序序列中找到最值，放入排序序列起始位置，再从未排序列中找最值，直至待排序列为空           改进可以选出每轮最大和最小
快速(冒泡改进)：选定一个元素，将大于这个元素，和小于这个元素分别放入两个序列中，在两个序列中按照这个规则排序
归并：分为两个长度一样的序列，递归排序，最后和并
插入：每一步都将元素插入到排好序的序列中适当位置，直至全部插入

```

```
//冒泡
	for (int i = 0; i < len - 1; ++i)
	{
		bool exchange = false;
		for (int j = 1; j < len - i; ++j)
		{
			if (arr[j - 1]>arr[j])
			{
				swap(arr[j-1],arr[j]);
				exchange = true;
			}
		}
		if (exchange == false)
		{
			return;
		}
	}
//选择
	for (int i = 0; i < len-1; ++i)
	{
		int k = i;//k保存最小的数
		for (int j =i+1; j < len-1; ++j)
		{
			if (arr[k]>arr[j])
			{
				k=j;
			}
		}
		if (k != i)
		{
			swap(arr[k], arr[i]);
		}
	}
//插入
for(var i=0;i<len;i++){
var key=data[i]; //待插数据
var j=i-1;
while(j>=0 && data[j]>key){
data[j+1]=data[i];
j--;
}
data[j+1]=key;
}
//快排

void _QuickSort1(int *arr,int left,int right)
{
	if (left >= right)
		return;
	int begin = left;
	int end = right - 1;
	int key = arr[right];
	while (begin < end)
	{
		if (begin < end && arr[begin] <= key)//找大
		{
			++begin;
		}
		if (begin < end && arr[end] >= key)//找小
		{
			--end;
		}
		if (begin <end)
		{
			swap(arr[begin], arr[end]);
		}
	}
	if (arr[begin] < key)
	{
		++begin;
	}
	swap(arr[begin], arr[right]);
	// 递归排序子序列
	_QuickSort1(arr, left, begin - 1);
	_QuickSort1(arr,begin + 1,right);
}
```


<div id="web" ></div>

## html，http，web基础

http和https的区别
<pre>
1、http协议：是超文本传输协议，信息是明文传输。80端口  免费申请
2、https协议：具有安全性的ssl/tls加密传输协议。443端口 需要到ca申请证书
</pre>

http1.0,2.0,3.0特性
<pre>
http请求有限制，超过会阻塞线程,延迟高，明文传输，报文数据重复
完全多路复用(解决了线程阻塞的问题)，使用报头压缩，采用二进制协议，服务器推送，https协议
增加了基于UDP的QUIC协议
</pre>

DNS工作原理
```
第一步：客户机提出域名解析请求，请求发送给本地的域名服务器。
第二步：本地域名服务器查询本地的缓存，如果有该纪录项，本地的域名服务器就直接把查询的结果返回。
第三步：如果本地的缓存中没有该纪录，则本地域名服务器就直接把请求发给根域名服务器，根域名服务器再返回给本地域名服务器一个查询域(根的子域) 的主域名服务器的地址。
第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。
第五步：重复第四步，直到找到正确的纪录。
第六步：本地域名服务器把返回的结果保存到缓存，结果返回给客户机。
```

进程和线程
```
进程是竞争计算机资源(分配和管理)的基本单位，是程序执行的实例
线程是进程的一部分，是程序执行的最小单位
```

ajax
<pre>
XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面

new XMLHttpRequest
open("post get","url",true异步)
send()
onreadystatechange
readystate || status
responseText responseXML

(http状态码)status:
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
常见的状态码有101切换协议，200成功，301永久重定向，302临时重定向，304未修改
readystate:
0 － （未初始化）还没有调用send()方法
1 － （载入）已调用send()方法，正在发送请求
2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
3 － （交互）正在解析响应内容
4 － （完成）响应内容解析完成，可以在客户端调用了
</pre>

http请求几种方法及区别
<pre>
简单请求：
head
get 通过url传递，所以传输数据小1024，安全性低，仅查询，不做修改
post 安全，没有传输限制，可修改
非简单请求：
delete 删除
put 更新
</pre>

cookie,session,localStorage区别，cookie的长度限制
<pre>
cookie 以键值对形式保存数据，作为HTTP请求响应的一部分，自定义保存时间，长度和数量的限制4k，安全隐患
sessionstorage 虽浏览器关闭删除数据5m，安全性高些，不用担心被截取
localStorage 除非用户删除，否则会一直存在本地，安全性高些，不用担心被截取
session 数据保存在服务器，安全性高，对服务器性能要求更高
</pre>

前端性能优化方法
<pre>
减少http请求 压缩图片 懒加载
减少域名数 cdn加速 css放在head js放在底部
代码优化:减少对doM的添加，删除操作
</pre>

浏览器输入url后发生了什么
<pre>
DNS域名解析
根据IP建立TCP连接（三次握手）
HTTP发起请求
服务器处理请求，浏览器接收HTTP响应
关闭TCP连接（四次挥手）
渲染页面，构建DOM树
</pre>

强缓存，协商缓存
<pre>
直接从本地副本比对读取，不去请求服务器，返回的状态码是 200。
会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。
</pre>

常见的块元素，行内元素，行内块元素
```
div p h table tr hr
a b i label
input img button
```

懒加载(延迟加载)
<pre>
先将img标签中的src链接设为同一张图片（空白图片），将真正的图片地址存储自定义属性中
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染，增加服务器负担
</pre>

xss攻击
<pre>
注入恶意代码到网页，用户加载并执行
盗用cookie
过滤html,js,css标签
</pre>

csrf攻击(跨站请求伪造)
<pre>
攻击者盗用了你的身份，以你的名义发送恶意请求
1.登录受信任网站A，并在本地生成Cookie。
2.在不登出A的情况下，访问危险网站B。
预防：验证码  表单增加伪随机数  
</pre>

同源策略
<pre>
仅同域名，同端口，同协议的网页可以通讯，无法读取非同源网页的 Cookie、LocalStorage，无法向非同源地址发送 AJAX 请求

跨域方法：
1.CORS:关键后端实现
2.postMessage: HTML5 XMLHttpRequest Level 2中的API
3.websocket:实现了浏览器与服务器的全双工通信
4.JSONP:利用javascript可以跨域，仅支持get请求
5.Nginx:需要搭建一个中转服务器，用于转发请求.反向代理实现跨域，是最简单的跨域方式.只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
</pre>

cdn
```
bootcdn
通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点
就近取得所需的内容，提高用户访问网站的响应速度,加速网页静态资源：图片，媒体，js,css
```

osi七层模型

```
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
```

<div id="csss" ></div>

## css

link和@import的区别
```
link:兼容性好，link标签引入的 CSS 被同时加载，可以定义其他属性；
import：只能加载css，不兼容老版本浏览器，@import引入的 CSS 将在页面加载完毕后被加载。
```

盒模型display:none，visibility:hidden和opcatity:0的区别
```
none：脱离文档流，不能触发事件，且不会被继承
hidden：不能触发事件，可以继承
0:可触发绑定事件，可以继承
```

margin塌陷
```
父子嵌套元素在垂直方向的margin,他们两个的margin会取较大值.
正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位.
但由于margin的塌陷,当子级magin大于父级会带着一起运动
解决,(创建BFC)父元素添加:
(1)position:absolute/fixed
(2)display:inline-block/table-cells/flex
(3)float:除了none外
(4)overflow:hidden/auto/scroll

magin合并：
块级元素的垂直外边距会互相合并，也就是会以他们之间外边距大的为准
解决：
将一边的边距设为两边距之和
```

清除浮动
```
clear:both
overflow:hidden
```

选择器优先级
```
    !important
    内联样式 
    id 选择器 
    伪类选择器 link active hover visited :first-child:last-child    类选择器 属性选择器 [attribute]
    伪元素 before after  元素(标签)选择器 
	 关系选择器+ >  统配选择器 * 
```

水平垂直居中
```
PC端有兼容性要求，宽高固定，推荐absolute + 负margin
PC端有兼容要求，宽高不固定，推荐css-table
PC端无兼容性要求，推荐flex
移动端推荐使用flex
```
<img src="/img/pos.PNG">

回流(重排)和重绘
```
浏览器渲染过程:
浏览器将获取的HTML文档并解析成DOM树。
css构成层叠样式表模型CSSOM(CSS Object Model)
将DOM和CSSOM合并为渲染树(rendering tree)

回流：当render tree中尺寸，布局，隐藏等改变需要重新构建render tree。这就称为回流(reflow)。  回流必重绘
重绘：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的。
```

精灵图(雪碧图)

```
很多的小图片合并到一张较大的图片里,使用是显示大图的特定位置和大小
缺点:维护麻烦，容易出现断裂
```

<div id="jss" ></div>

## js 

闭包，内存泄漏
```
访问函数内部变量
利用垃圾回收机制，被引用的变量不会被回收，所以会造成内存泄漏
```

作用域链，变量提升
```
变量提升优先级小于函数提升
每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链,搜索是一级一级往上搜索，一旦找到不再搜索
变量提升：使用了在下面定义的变量，把变量提升到函数顶部，但使用时变量值为undefined
函数提升:和变量提升类似，但是只有声明会被提升，函数表达式，构造不会被提升
```

常用数组，字符串方法
```
数组：join pop push reverse sort unshift shift concat
filter find map foreach every some isArray  slice splice tostring
字符串:split slice concat match replace search
```

map和foreach区别
```
都是遍历数组每一项，都不可中断循环
1.map()不会更改原数组，返回新数组，链式使用
2.forEach()可以更改原数组，没有返回值，不能链式使用，速度更快
```

js事件循环机制，宏任务微任务
```
事件循环：
（1）同步任务在主线程上执行，形成一个执行栈（execution context stack）。
（2）子线程(任务队列)执行异步任务。异步任务(定时器,事件)按顺序放入"任务队列"中。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"。
（4）述过程会不断重复，也就是常说的Event Loop(事件循环)
宏任务：每次执行栈执行的代码就是一个宏任务，所有宏任务都是添加到任务队列，所以”任务队列又叫宏任务队列”，
这个任务队列由事件触发线程来单独维护的。 定时器，script
微任务
当前宏任务执行结束后立即执行的任务。 promise,async/await
```

解决回调地狱
```
promise
generator协程
async/ await 后面非promise等于同步操作
```

原型链
```
指向原型__proto__ 指向原型构造函数constructor 指向函数原型对象prototype
在JavaScript中通过__proto__ 指向prototype，直到指向Object对象为止，就形成了一个原型指向的链条，称之为原型链。
当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，没有则会去原型对象中寻找,
直到找到Object对象的原型,如果在Object原型(null)中依然没有找到，则返回undefined。
```

<img src="/img/原型链.PNG">

对象继承方法
```
原型继承：不能多继承
构造函数继承call/apply:只能继承父类实例的方法，不能继承原型方法
组合继承：原型加构造继承，最常用，生成了两份实例
寄生组合继承:执行效率最高，应用面最广，实现复杂
es6的extends继承
```

new做了什么操作
```
(1) 创建一个新对象
(2) 构造函数this 指向这个新对象 
(3) 执行构造函数中的代码（为这个新对象添加属性）
(4) 返回新对象
```

bind,call,apply的区别
```
第一个参数都是this的指向对象
bind 返回值是函数
call 
apply 参数是数组
```

this指向
```
三种情况：
有对象，指向对象
无对象，指向全局对象window
改变指向bind call apply
箭头函数 向上捕获this
```

设计模式，应用场景
```
1) 单例模式
只包含一个被称为单例类的特殊类。
通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。
2) 工厂模式
工厂模式主要是封装实现细节，只提供了接口
3) 模板模式
定义抽象类，类中定义一些方法，子类继承抽象类，并重写方法
4) 观察者模式(发布者/订阅模式)
对象间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
```

垃圾回收机制
```
标记清除：当变量被引用，标记为进入环境，离开时标记为离开环境，变量加上"销毁"标记
最后,垃圾收集器销毁那些带有"销毁"标记的变量并回收它们所占用的内存空间
引用计数：引用计数器加一，包含变量值获得另一个值减一。会导致内存泄漏
```

js动画和css动画区别
```
js：复杂，对动画能有更多控制，性能更差，兼容性好
css: 简单，性能好，兼容性差
```

模块化
```
引入js脚本太多，重名，变量污染，可能存在依赖关系，需要按顺序加载
1.闭包和命名空间
2.CommonJs:文件内通过require对象引入指定模块,通过module关键字暴露内容,只能在服务端环境上运行
3.AMD和RequireJS
4.CMD和SeaJs
5.es6模块化：
	 export 变量名
     import * as(重命名) from src
```

防抖节流
```
绑定触发高频率的事件，scroll,mousemove等，希望降低触发频率
防抖：事件在n秒内执行一次，如果又触发了，时间清零
节流：每隔n秒执行一次函数
```

深浅拷贝
```
浅拷贝：拷贝多份非数字型数据，改变一份数据，会同时改变其他数据
深拷贝：改变数据，不改变其他数据
实现:JSON.parse(JSON.stringify())   递归   forEach
for in会迭代原型链的属性
for of ES6新特性，只会迭代对象本身的属性
```

dom0级事件dom2级事件
```
0级：同一个元素绑定多个事件,只会绑定最后一个事件，只能在事件冒泡阶段触发
绑定：dom.onclick
解除绑定：dom.onclick=null

2级：可以监听多个事件，只有2级DOM有完整的事件流
绑定：dom.addEventListener(type,function,false)  
解除绑定:dom.removeEventListener(type,function,false)
true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序
```

事件流
```
接收事件的顺序,分为三个阶段
事件捕获阶段(从父元素传递到子元素)
处于目标阶段(绑定事件的那个元素)
事件冒泡阶段(子元素传递到父元素)
```


数组去重
```
ES6 Set去重new Set(array)
```

数组展平
```
toString   
array.flat(Infinity(层数))
```

typeof 和instance of
```
基本类型：number、boolean、string、object、null、undefined,symbol
typeof：只能表示7种类型 number、boolean、string、function、object(null返回值)、undefined,symbol
instance of：检测某个对象是不是另一个对象的实例，能判断object子类
```

为什么0.1+0.2！=0.3
```
浮点数在计算机中不可以精确表示，只是近似值，计算结果也是近似值
```

<div id="vues" ></div>

## vuejs篇

为什么采用异步渲染
```
性能影响大，每次数据更新都要对组件重新渲染
```

双向绑定原理
```
发布者模式+数据劫持监听
```

mvvm和mvc差异
```
mvc:view传送命令到controller完成业务逻辑要求model改变状态model将新的数据发送给view，用户得到反馈	
mvvm:view 和 model不能直接交互,view model 通过viewmodel交互，实现view和model双向绑定

```

父子通信 非父子通信
```
父子：props
非父子:创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件
```

生命周期(组件,实例)
```
创建：页面创建后执行beforeCreate，初始化，然后执行created函数，可以使用vm本身的属性和方法
挂载：执行beforeMount(可以更改数据，不会触发updated)，虚拟dom放入到render函数中准备渲染，执行mounted,渲染出真实dom
更新：当组件或实例的数据更改之后，会立即执行beforeUpdate，虚拟DOM放入render函数中重新渲染，更新完成后，执行updated，重新渲染真实dom
销毁：beforeDestroy还可以操作实例  destroyed
```

key的作用
```
唯一标识元素，满足重新渲染的需求(不再复用元素)
```

v-if v-show
```
v-if 只有满足条件才渲染，有更高的切换开销
v-show 不管是否满足条件，都会被渲染，只是切换display，有更高的初始化开销
```

<div id="hr"></div>

## 主管/hr面问题

```
自我介绍
说说优势
写过多少代码
怎么和人合作编程，遇到矛盾怎么处理
平时怎么学习的
为什么选择学习这方面知识
职业规划
你有什么优点（与众不同的东西）
你有什么缺点（别傻傻的光说缺点，说说你是怎么克服，或者绕开它们的呀）
兴趣爱好
平时作息时间
```