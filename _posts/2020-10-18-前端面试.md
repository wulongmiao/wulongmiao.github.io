---
layout: post
title: 前端面试
date:  2020-10-18
categories: 前端
tags: [前端开发,面试]
---
## 面试考点导图

<img src="/img/mianshi.png">

## html，http，web基础

h5新特性
<pre>
标签：canvas,audio,video，datelist,onput 地理位置
事件：onresize、ondrag、onscroll,onerror
</pre>

http和https的区别
<pre>
1、http协议：是超文本传输协议，信息是明文传输。80端口  免费申请
2、https协议：具有安全性的ssl加密传输协议。443端口 需要到ca申请证书
</pre>

http1.0,1.1,2.0,3.0特性
<pre>
网站的内容是开发者提供的
用户与网站交互性
即时通讯，不同网站可以直接交互
</pre>

http状态码
<pre>
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
</pre>

http请求几种方法及区别
<pre>
get 通过url传递，所以传输数据小1024，安全性低，仅查询，不做修改
post 安全，没有传输限制，可修改
delete 删除
put 更新
</pre>

cookie,session,localStorage区别，cookie的长度限制
<pre>
cookie 以键值对形式保存数据，作为HTTP请求响应的一部分，扩展性和可用性，自定义保存时间，长度和数量的限制4k，安全隐患
sessionstorage 虽浏览器关闭删除数据5m，安全性高些，不用担心被截取
localStorage 除非用户删除，否则会一直存在本地，安全性高些，不用担心被截取
</pre>

前端性能优化方法
<pre>
减少http请求 压缩图片 css放在head js放在底部 代码优化
</pre>

浏览器输入url后发生了什么
<pre>
浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
DNS解析URL对应的IP。
根据IP建立TCP连接（三次握手）。
HTTP发起请求。
服务器处理请求，浏览器接收HTTP响应。
渲染页面，构建DOM树。
关闭TCP连接（四次挥手）。
</pre>

websocket

```WebSocket 是 HTML5 开始提供的一种 TCP 连接上进行全双工通讯的协议```

强缓存(本地缓存)，协商缓存
<pre>
直接从本地副本比对读取，不去请求服务器，返回的状态码是 200。
会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。
</pre>

常见的块元素，行内元素，行内块元素
```
div p h table
a b i
input ,img,td
```

懒加载(延迟加载)
<pre>
先将img标签中的src链接设为同一张图片（空白图片），将真正的图片地址存储自定义属性中
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染，增加服务器负担
</pre>

xss攻击
<pre>
注入恶意代码到网页，用户加载并执行
盗用cookie
过滤html,js,css标签
</pre>

csrf攻击(跨站请求伪造)
<pre>
攻击者盗用了你的身份，以你的名义发送恶意请求
1.登录受信任网站A，并在本地生成Cookie。
2.在不登出A的情况下，访问危险网站B。
预防：验证码  表单增加伪随机数  
</pre>

同源策略
<pre>
仅同域名，同端口，同协议的网页可以通讯，无法读取非同源网页的 Cookie、LocalStorage，无法向非同源地址发送 AJAX 请求
</pre>

cnd

```通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度```

dns

```域名解析```

osi七层模型

```物理层、数据链路层、网络层、传输层、会话层、表示层、应用层```

常用端口号

```80  8080  443```

## css

link和@import的区别
```
link:兼容性好，link标签引入的 CSS 被同时加载，可以定义其他属性；
import：只能加载css，不兼容老版本浏览器，@import引入的 CSS 将在页面加载完毕后被加载。
```

盒模型display:none，visibility:hidden和opcatity:0的区别
```
none：脱离文档流，不能触发事件，且不会被继承
hidden：不能触发事件，可以继承
0:可触发绑定事件，可以继承
```

margin塌陷
```
父子嵌套元素在垂直方向的margin,他们两个的margin会取较大值.
正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位.
但由于margin的塌陷,当子级magin大于父级会带着一起运动
解决,父元素添加:
(1)position:absolute/fixed
(2)display:inline-block;
(3)float:left/right
(4)overflow:hidden
magin合并：
上下位置的块级，如果两个magintop,bottom值相同时，则两容器间的距离就是这个值；如果两个属性的值不同，则取较大值作为两容器间的距离
```

清除浮动
```
clear:both
overflow:hidden
```

选择器优先级
```
    !important
    内联样式 
    id 选择器 
    伪类选择器 link active hover visited :first-child:last-child
    类选择器 属性选择器 [attribute]
    伪元素 before after
    元素(标签)选择器 
    关系选择器+ >
    统配选择器 * 
```

水平垂直居中
```
PC端有兼容性要求，宽高固定，推荐absolute + 负margin
PC端有兼容要求，宽高不固定，推荐css-table
PC端无兼容性要求，推荐flex
移动端推荐使用flex
```
<img src="/img/pos.PNG">

媒介查询相关的自适应布局
```
@media screen and (min-width:px)
max-device-width：用于创建手机版网站
max-width：用于针对窗口宽度设定不同的样式
orientation：用于根据平板电脑或iPad的横向或者竖向来改变布局
```

回流和重绘
```
浏览器把获取到的HTML代码解析成1个DOM tree，浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体，DOM Tree 和样式结构体组合后构建render tree
回流：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。
重绘：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。
```

flex布局
```
弹性布局，一维布局
```

精灵图

```
很多的小图片合并到一张较大的图片里,使用是显示大图的特定位置和大小
```

## js 


闭包，内存泄漏
```
利用垃圾回收机制，被引用的变量不会被回收，所以会造成内存泄漏
```

作用域链，变量提升
```
每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链,搜索是一级一级往上搜索，一旦找到不再搜索
变量提升：使用了在下面定义的变量，把变量提升到函数顶部，但使用时变量值为undefined
函数提升:和变量提升类似，但是只有声明会被提升，函数表达式，构造不会被提升
```

常用数组，字符串方法
```
数组：join pop push reverse sort unshift shift concat
filter find map foreach every some isArray  slice splice tostring
字符串:split slice concat match replace search
```

map和foreach区别
```
都是遍历数组每一项，都不可中断循环
1.map()不会更改原数组，返回新数组，链式使用
2.forEach()可以更改原数组，没有返回值，不能链式使用，速度更快
```

js事件循环机制，宏任务微任务
```
事件循环：
（1）同步任务在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"。
（4）述过程会不断重复，也就是常说的Event Loop(事件循环)
宏任务：每次执行栈执行的代码就是一个宏任务，所有宏任务都是添加到任务队列，所以”任务队列又叫宏任务队列”，这个任务队列由事件触发线程来单独维护的
微任务
可以理解是在当前宏任务执行结束后立即执行的任务
```

解决回调地狱
```
promise
generator
async/await
```

原型链
```
指向原型__proto__ 指向原型构造函数constructor 指向函数原型对象prototype
在JavaScript中通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。
当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，没有则会去原型对象中寻找,直到找到Object对象的原型,如果在Object原型中依然没有找到，则返回undefined。
```

<img src="/img/原型链.PNG">

对象继承方法
```
原型继承，构造函数继承，call/apply继承以及es6的extend继承

```

new做了什么操作
```
(1) 创建一个新对象；
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；
(3) 执行构造函数中的代码（为这个新对象添加属性） ；
(4) 返回新对象。
```

bind,call,apply的区别
```
第一个参数都是this的指向对象
bind 返回值是函数
call 
apply 参数是数组
```

ajax    
```
readystate:
0 － （未初始化）还没有调用send()方法
1 － （载入）已调用send()方法，正在发送请求
2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
3 － （交互）正在解析响应内容
4 － （完成）响应内容解析完成，可以在客户端调用了
status
1**：请求收到，继续处理
2**：操作成功收到，分析、接受
3**：完成此请求必须进一步处理
4**：请求包含一个错误语法或不能完成
5**：服务器执行一个完全有效请求失败
```

this指向
```
四种情况：
有对象，指向对象
无对象，指向全局对象window
改变指向bind call apply
改变指向 箭头函数 
```

设计模式，应用场景
```
1) 单例模式。
单例模式是一种常用的软件设计模式。
在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。
应用场景：希望在系统中某个类的对象只能存在一个
2) 工厂模式。
工厂模式主要是为创建对象提供了接口。
应用场景如下：
a、 在编码时不能预见需要创建哪种类的实例。
b、 系统不应依赖于产品类实例如何被创建、组合和表达的细节。
3) 策略模式。
策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。
应用场景如下。
a、 一件事情，有很多方案可以实现。
b、我可以在任何时候，决定采用哪一种实现。
c.、未来可能增加更多的方案。
d、 策略模式让方案的变化不会影响到使用方案的客户。
举例业务场景如下。
系统的操作都要有日志记录，通常会把日志记录在数据库里面，方便后续的管理，但是在记录日志到数据库的时候，可能会发生错误，比如暂时连不上数据库了，那就先记录在文件里面。日志写到数据库与文件中是两种算法，但调用方不关心，只负责写就是。
4) 观察者模式。
观察者模式又被称作发布/订阅模式，定义了对象间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
应用场景如下：
a、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
b、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。
5) 迭代器模式。
迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
应用场景如下：
当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍 历的时候，就应该考虑用迭代器模式。其实stl容器就是很好的迭代器模式的例子。
6) 模板方法模式。
模板方法模式定义一个操作中的算法的骨架，将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。
应用场景如下：
对于一些功能，在不同的对象身上展示不同的作用，但是功能的框架是一样的。
```

垃圾回收机制
```
标记清除：当变量被引用，标记为进入环境，离开时标记为离开环境，变量加上"销毁"标记.最后,垃圾收集器销毁那些带有"销毁"标记的变量并回收它们所占用的内存空间.
引用计数：会导致内存泄漏
```

js动画和css动画区别
```
js：复杂，对动画能有更多控制，性能更差，兼容性好
css: 简单，性能好，兼容性差
```

模块化
```
引入js脚本太多，重名，变量污染，可能存在依赖关系，需要按顺序加载
闭包和命名空间
 CommonJs:文件内通过require对象引入指定模块,通过module关键字暴露内容,只能在服务端环境上运行
  AMD和RequireJS:require([module], callback);  要加载的模块，加载成功的回调函数
 CMD和SeaJs：
es6模块化
```

防抖节流
```
绑定触发高频率的事件，scroll,mousemove等，希望降低触发频率
防抖：事件在n秒内执行一次，如果又触发了，时间清零
节流：每隔n秒执行一次函数
```

深浅拷贝
```
浅拷贝：拷贝多份非数字型数据，改变一份数据，会同时改变其他数据
深拷贝：改变数据，不改变其他数据
实现:JSON.parse(JSON.stringify())   递归  for in循环
```

dom0级事件dom2级事件
```
0级：onclick
2级：监听方法 addEventListener()和removeEventListener()。
只有2级DOM包含3个事件：事件捕获阶段、处于目标阶段和事件冒泡阶段
```

事件流
```
HTML中与javascript交互是通过事件驱动来实现的,事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。
什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。
事件捕获阶段
处于目标阶段
事件冒泡阶段
addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。
```

浏览器渲染过程
```
浏览器将获取的HTML文档并解析成DOM树。
处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
将DOM和CSSOM合并为渲染树(rendering tree)
渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素。
将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting.
```

数组去重
```
法一：indexOf循环去重
法二：ES6 Set去重；Array.from(new Set(array))
法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。
```

数组展平
```
tostring   contact  arr.flat(Infinity)层数
```

typeof 和instance of
```
typeof；只能表示7种基本类型
instance of：检测某个对象是不是另一个对象的实例，能判断object子类
```

为什么0.1+0.2！=0.3
```
浮点数在计算机中不可以精确表示，只是近似值，计算结果也是近似值
```

## vuejs篇

双向绑定原理
```
v-model
```

mvvm和mvc差异

（和项目开发一个道理，小公司接小项目，boss从客户那接了单给程序员做，程序员做了给客户看，客户看了不满意找领导，领导找程序员，这么个循环就是mvc；公司大了，项目大了领导不管了，那就是客户需求和产品经理说，产品经理和程序员对接，程序员做完给产品经理看，产品再去把东西给客户，这就是mvvm）
```
mvc:Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View，比如在controller中写document.getElementById("box").innerHTML = data[”title”]，只是还没有刻意建一个Model类出来而已。
mvvm:
```

父子通信 非父子通信
```
props
```

生命周期
```
Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。
每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。
实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作
挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取
接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取
接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...
当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿
当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom
当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等
组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以
```

key的作用
```
唯一标识元素，满足重新渲染的需求
```

v-if
```
只有满足条件，才会被渲染
```

## 主管/hr面问题
```
自我介绍
最有成就感的事
最失败的经历
最近读过什么书
写过多少代码
怎么和人合作编程，遇到矛盾怎么处理
平时怎么学习的
为什么选择学习这方面知识
职业规划
你有什么优点（与众不同的东西）
你有什么缺点（别傻傻的光说缺点，说说你是怎么克服，或者绕开它们的呀）
兴趣爱好
平时作息时间
```