---
layout: post
title: 前端面试
date:  2020-10-18
categories: 前端
tags: [前端开发,面试]
---
## 目录

<div><a href="#mianshi" target="_self">1. 面试考点导图</a></div>
<div><a href="#sjjg" target="_self">2. 数据结构和算法</a></div>
<div><a href="#web" target="_self">3. html，http，web基础</a></div>
<div><a href="#csss" target="_self">4. css</a></div>
<div><a href="#jss" target="_self">5. js</a></div>
<div><a href="#vues" target="_self">6. vuejs</a></div>
<div><a href="#hr" target="_self">7. hr面</a></div>
<div id="mianshi" ></div>

## 面试考点导图

<img src="/img/mianshi.png">
<div id="sjjg" ></div>

## 数据结构和算法

```
二叉树：
// 先建立一棵树
function node(obj) {
    var newobj = {};
    if(obj.length == 1) {
        newobj.value = obj[0];
    }else if(obj.length == 0){
        newobj.value == null;
    }else{
        newobj.left = node(obj[0]);
        newobj.value = obj[1];
        newobj.right = node(obj[2]);
    }
    return newobj;
}

var root = node([[[[7], 11, [2]], 4, []], 5, [[13], 8, [[], 4, [1]]]])
// 中序遍历
function goTree1(tree) {
    if(tree.hasOwnProperty('left')){
        goTree1(tree.left);
        console.log(tree.value);
        goTree1(tree.right);
    }else{
        (tree.value == null)? console.log(""): console.log(tree.value);
    }
}

// 前序遍历
function goTree2(tree) {
    (tree.value == null)? console.log(""): console.log(tree.value);
    if(tree.hasOwnProperty('left')){
        goTree2(tree.left);
        goTree2(tree.right);
    }
}

// 后序遍历
function goTree3(tree) {
    if(tree.hasOwnProperty('left')){
        goTree3(tree.left);
        goTree3(tree.right);
        console.log(tree.value);
    }else{
        (tree.value == null)? console.log(""): console.log(tree.value);
    }
}

//层序遍历
// 层序遍历需要使用队列的数据结构，这里可以用数组来替代
// 这里不能使用迭代
function goTree4(tree) {
    let deque = [];
    deque.push(root);
    while(deque.length != 0){
        front = deque.shift()
        if(front.hasOwnProperty('left')){
            deque.push(front.left);
            deque.push(front.right);
        }
        (front.value == null)? console.log(""): console.log(front.value);
    }
}
禁止尾递归防止栈溢出，所有递归的放在函数末尾
```

<img src="/img/排序算法.png">

排序算法:
```
冒泡：重复遍历，比较两个元素，判断是否需要交换
选择：在待排序序列中找到最值，放入排序序列起始位置，再从未排序列中找最值，直至待排序列为空           改进可以选出每轮最大和最小
快速(冒泡改进)：选定一个元素，将大于这个元素，和小于这个元素分别放入两个序列中，在两个序列中按照这个规则排序
归并：分为两个长度一样的序列，递归排序，最后和并
插入：每一步都将元素插入到排好序的序列中适当位置，直至全部插入

```

```
//冒泡
	for (int i = 0; i < len - 1; ++i)
	{
		bool exchange = false;
		for (int j = 1; j < len - i; ++j)
		{
			if (arr[j - 1]>arr[j])
			{
				swap(arr[j-1],arr[j]);
				exchange = true;
			}
		}
		if (exchange == false)
		{
			return;
		}
	}
//选择
	for (int i = 0; i < len-1; ++i)
	{
		int k = i;//k保存最小的数
		for (int j =i+1; j < len-1; ++j)
		{
			if (arr[k]>arr[j])
			{
				k=j;
			}
		}
		if (k != i)
		{
			swap(arr[k], arr[i]);
		}
	}
//插入
for(var i=0;i<len;i++){
var key=data[i]; //待插数据
var j=i-1;
while(j>=0 && data[j]>key){
data[j+1]=data[i];
j--;
}
data[j+1]=key;
}
//快排

void _QuickSort1(int *arr,int left,int right)
{
	if (left >= right)
		return;
	int begin = left;
	int end = right - 1;
	int key = arr[right];
	while (begin < end)
	{
		if (begin < end && arr[begin] <= key)//找大
		{
			++begin;
		}
		if (begin < end && arr[end] >= key)//找小
		{
			--end;
		}
		if (begin <end)
		{
			swap(arr[begin], arr[end]);
		}
	}
	if (arr[begin] < key)
	{
		++begin;
	}
	swap(arr[begin], arr[right]);
	// 递归排序子序列
	_QuickSort1(arr, left, begin - 1);
	_QuickSort1(arr,begin + 1,right);
}
```


<div id="web" ></div>

## html，http，web基础

h5新特性
<pre>
标签：canvas,audio,video，datelist,onput 地理位置
事件：onresize、ondrag、onscroll,onerror
</pre>

http和https的区别
<pre>
1、http协议：是超文本传输协议，信息是明文传输。80端口  免费申请
2、https协议：具有安全性的ssl加密传输协议。443端口 需要到ca申请证书
</pre>

http1.0,1.1,2.0,3.0特性
<pre>
网站的内容是开发者提供的
用户与网站交互性
即时通讯，不同网站可以直接交互
</pre>

进程和线程
```
进程是竞争计算机资源(分配和管理)的基本单位，是程序执行的实例
线程是进程的一部分，是程序执行的最小单位
```

ajax
<pre>
(http状态码)status:
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
常见的状态码有101切换协议，200成功，301永久重定向，302临时重定向，304未修改
readystate:
0 － （未初始化）还没有调用send()方法
1 － （载入）已调用send()方法，正在发送请求
2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
3 － （交互）正在解析响应内容
4 － （完成）响应内容解析完成，可以在客户端调用了
</pre>

http请求几种方法及区别
<pre>
get 通过url传递，所以传输数据小1024，安全性低，仅查询，不做修改
post 安全，没有传输限制，可修改
delete 删除
put 更新
</pre>

cookie,session,localStorage区别，cookie的长度限制
<pre>
cookie 以键值对形式保存数据，作为HTTP请求响应的一部分，扩展性和可用性，自定义保存时间，长度和数量的限制4k，安全隐患
sessionstorage 虽浏览器关闭删除数据5m，安全性高些，不用担心被截取
localStorage 除非用户删除，否则会一直存在本地，安全性高些，不用担心被截取
session 安全性高些，对服务器性能要求更高
</pre>

前端性能优化方法
<pre>
减少http请求 压缩图片 懒加载
减少域名数 cdn加速 css放在head js放在底部
代码优化:减少对doM的添加，删除操作
</pre>

浏览器输入url后发生了什么
<pre>
浏览器查找当前URL是否存在缓存(浏览器缓存，服务器缓存，路由器缓存)，并比较缓存是否过期。
DNS解析URL对应的IP。
根据IP建立TCP连接（三次握手）。
HTTP发起请求。
服务器处理请求，浏览器接收HTTP响应。
渲染页面，构建DOM树。
关闭TCP连接（四次挥手）。
</pre>

websocket

```
WebSocket 是 HTML5 开始提供的一种 TCP 连接上进行全双工通讯的协议
```

强缓存，协商缓存
<pre>
直接从本地副本比对读取，不去请求服务器，返回的状态码是 200。
会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。
</pre>

常见的块元素，行内元素，行内块元素
```
div p h table,tr
a b i label
input ,img,td,button
```

懒加载(延迟加载)
<pre>
先将img标签中的src链接设为同一张图片（空白图片），将真正的图片地址存储自定义属性中
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染，增加服务器负担
</pre>

xss攻击
<pre>
注入恶意代码到网页，用户加载并执行
盗用cookie
过滤html,js,css标签
</pre>

csrf攻击(跨站请求伪造)
<pre>
攻击者盗用了你的身份，以你的名义发送恶意请求
1.登录受信任网站A，并在本地生成Cookie。
2.在不登出A的情况下，访问危险网站B。
预防：验证码  表单增加伪随机数  
</pre>

同源策略
<pre>
仅同域名，同端口，同协议的网页可以通讯，无法读取非同源网页的 Cookie、LocalStorage，无法向非同源地址发送 AJAX 请求
</pre>

cdn
```
bootcdn
通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点
就近取得所需的内容，提高用户访问网站的响应速度,加速网页静态资源：图片，媒体，js,css
```

osi七层模型

```
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
```

<div id="csss" ></div>

## css

link和@import的区别
```
link:兼容性好，link标签引入的 CSS 被同时加载，可以定义其他属性；
import：只能加载css，不兼容老版本浏览器，@import引入的 CSS 将在页面加载完毕后被加载。
```

盒模型display:none，visibility:hidden和opcatity:0的区别
```
none：脱离文档流，不能触发事件，且不会被继承
hidden：不能触发事件，可以继承
0:可触发绑定事件，可以继承
```

margin塌陷
```
父子嵌套元素在垂直方向的margin,他们两个的margin会取较大值.
正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位.
但由于margin的塌陷,当子级magin大于父级会带着一起运动
解决,父元素添加:
(1)position:absolute/fixed
(2)display:inline-block;
(3)float:left/right
(4)overflow:hidden
magin合并：
上下位置的块级，如果两个magintop,bottom值相同时，则两容器间的距离就是这个值；
如果两个属性的值不同，则取较大值作为两容器间的距离
```

清除浮动
```
clear:both
overflow:hidden
```

选择器优先级
```
    !important
    内联样式 
    id 选择器 
    伪类选择器 link active hover visited :first-child:last-child
    类选择器 属性选择器 [attribute]
    伪元素 before after
    元素(标签)选择器 
    关系选择器+ >
    统配选择器 * 
```

水平垂直居中
```
PC端有兼容性要求，宽高固定，推荐absolute + 负margin
PC端有兼容要求，宽高不固定，推荐css-table
PC端无兼容性要求，推荐flex
移动端推荐使用flex
```
<img src="/img/pos.PNG">

媒介查询相关的自适应布局
```
@media screen and (min-width:px)
max-device-width：用于创建手机版网站
max-width：用于针对窗口宽度设定不同的样式
orientation：用于根据平板电脑或iPad的横向或者竖向来改变布局
```

回流(重排)和重绘
```
浏览器渲染过程:
浏览器将获取的HTML文档并解析成DOM树。
css构成层叠样式表模型CSSOM(CSS Object Model)
将DOM和CSSOM合并为渲染树(rendering tree)

回流：当render tree中尺寸，布局，隐藏等改变需要重新构建render tree。这就称为回流(reflow)。  回流必重绘
重绘：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的。
```

精灵图(雪碧图)

```
很多的小图片合并到一张较大的图片里,使用是显示大图的特定位置和大小
缺点:维护麻烦，容易出现断裂
```

<div id="jss" ></div>

## js 

闭包，内存泄漏
```
利用垃圾回收机制，被引用的变量不会被回收，所以会造成内存泄漏
```

作用域链，变量提升
```
变量提升优先级大于函数提升
每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链,搜索是一级一级往上搜索，一旦找到不再搜索
变量提升：使用了在下面定义的变量，把变量提升到函数顶部，但使用时变量值为undefined
函数提升:和变量提升类似，但是只有声明会被提升，函数表达式，构造不会被提升
```

常用数组，字符串方法
```
数组：join pop push reverse sort unshift shift concat
filter find map foreach every some isArray  slice splice tostring
字符串:split slice concat match replace search
```

map和foreach区别
```
都是遍历数组每一项，都不可中断循环
1.map()不会更改原数组，返回新数组，链式使用
2.forEach()可以更改原数组，没有返回值，不能链式使用，速度更快
```

js事件循环机制，宏任务微任务
```
事件循环：
（1）同步任务在主线程上执行，形成一个执行栈（execution context stack）。
（2）子线程(任务队列)执行异步任务。异步任务按顺序放入"任务队列"中。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"。
（4）述过程会不断重复，也就是常说的Event Loop(事件循环)
宏任务：每次执行栈执行的代码就是一个宏任务，所有宏任务都是添加到任务队列，所以”任务队列又叫宏任务队列”，
这个任务队列由事件触发线程来单独维护的。 定时器，script
微任务
当前宏任务执行结束后立即执行的任务。 promise,async/await
```

解决回调地狱
```
promise
generator协程
async/ await 后面非promise等于同步操作
```

原型链
```
指向原型__proto__ 指向原型构造函数constructor 指向函数原型对象prototype
在JavaScript中通过__proto__ 指向prototype，直到指向Object对象为止，就形成了一个原型指向的链条，称之为原型链。
当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，没有则会去原型对象中寻找,
直到找到Object对象的原型,如果在Object原型(null)中依然没有找到，则返回undefined。
```

<img src="/img/原型链.PNG">

对象继承方法
```
原型继承：不能多继承
构造函数继承call/apply:只能继承父类实例的方法，不能继承原型方法
组合继承：原型加构造继承，最常用，生成了两份实例
寄生组合继承:执行效率最高，应用面最广，实现复杂
es6的extends继承

```

new做了什么操作
```
(1) 创建一个新对象
(2) 构造函数this 指向这个新对象 
(3) 执行构造函数中的代码（为这个新对象添加属性）
(4) 返回新对象
```

bind,call,apply的区别
```
第一个参数都是this的指向对象
bind 返回值是函数
call 
apply 参数是数组
```

this指向
```
三种情况：
有对象，指向对象
无对象，指向全局对象window
改变指向bind call apply
箭头函数 向上捕获this
```

设计模式，应用场景
```
1) 单例模式
只包含一个被称为单例类的特殊类。
通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。
应用场景：希望在系统中某个类的对象只能存在一个
2) 工厂模式
工厂模式主要是封装实现细节，只提供了接口
应用场景如下：
a、 在编码时不能预见需要创建哪种类的实例。
b、 系统不应依赖于产品类实例如何被创建、组合和表达的细节。
3) 模板模式
定义抽象类，类中定义一些方法，子类继承抽象类，并重写方法
应用场景如下：
对于一些功能，在不同的对象身上展示不同的作用，但是功能的框架一样
4) 观察者模式(发布者/订阅模式)
对象间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
应用场景如下：
a、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
b、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。
```

垃圾回收机制
```
标记清除：当变量被引用，标记为进入环境，离开时标记为离开环境，变量加上"销毁"标记
最后,垃圾收集器销毁那些带有"销毁"标记的变量并回收它们所占用的内存空间
引用计数：引用计数器加一，包含变量值获得另一个值减一。会导致内存泄漏
```

js动画和css动画区别
```
js：复杂，对动画能有更多控制，性能更差，兼容性好
css: 简单，性能好，兼容性差
```

模块化
```
引入js脚本太多，重名，变量污染，可能存在依赖关系，需要按顺序加载
1.闭包和命名空间
2.CommonJs:文件内通过require对象引入指定模块,通过module关键字暴露内容,只能在服务端环境上运行
3.AMD和RequireJS:
             模块定义define("模块名", ["依赖", "需要先加载"],function)
             模块加载require([module], callback)
4.CMD和SeaJs：
             模块定义define(factory) factory可以是变量，函数
             模块加载seajs.use
5.es6模块化：
         export 变量名
         import * as(重命名) from src
```

防抖节流
```
绑定触发高频率的事件，scroll,mousemove等，希望降低触发频率
防抖：事件在n秒内执行一次，如果又触发了，时间清零
节流：每隔n秒执行一次函数
```

深浅拷贝
```
浅拷贝：拷贝多份非数字型数据，改变一份数据，会同时改变其他数据
深拷贝：改变数据，不改变其他数据
实现:JSON.parse(JSON.stringify())   递归  for in(of)
```

dom0级事件dom2级事件
```
0级：同一个元素绑定相同事件,后面函数会覆盖前面的，只能在事件冒泡阶段触发
绑定：dom.onclick
解除绑定：dom.onclick=null

2级：可以监听多个事件，只有2级DOM有完整的事件流
绑定：dom.addEventListener(type,function,false)  
解除绑定:dom.removeEventListener(type,function,false)
true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序
```

事件流
```
接收事件的顺序,分为三个阶段
事件捕获阶段(从父元素传递到子元素)
处于目标阶段(绑定事件的那个元素)
事件冒泡阶段(子元素传递到父元素)
```


数组去重
```
indexOf循环去重
ES6 Set去重new Set(array)
```

数组展平
```
toString   
array.flat(Infinity(层数))
```

typeof 和instance of
```
typeof：只能表示7种基本类型
instance of：检测某个对象是不是另一个对象的实例，能判断object子类
```

为什么0.1+0.2！=0.3
```
浮点数在计算机中不可以精确表示，只是近似值，计算结果也是近似值
```

<div id="vues" ></div>

## vuejs篇

为什么采用异步渲染
```
性能影响大，每次数据更新都要对组件重新渲染
```

双向绑定原理
```
发布者模式+数据劫持监听
```

mvvm和mvc差异
```
mvc:view传送命令到controller完成业务逻辑要求model改变状态model将新的数据发送给view，用户得到反馈
mvvm:view 和 model不能直接交互,view model 通过viewmodel交互，实现view和model双向绑定

```

父子通信 非父子通信
```
父子：props
非父子:创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件
```

生命周期
```
Vue实例或者组件有完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程。分为三个阶段：初始化、运行中、销毁。
```

实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作
挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取
接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取
接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情...
当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿
当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom
当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等
组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以

key的作用
```
唯一标识元素，满足重新渲染的需求(不再复用元素)
```

v-if v-show
```
v-if 只有满足条件才渲染，有更高的切换开销
v-show 不管是否满足条件，都会被渲染，只是切换display，有更高的初始化开销
```
<div id="hr"></div>

## 主管/hr面问题
```
自我介绍
最有成就感的事
最失败的经历
说说优势
写过多少代码
怎么和人合作编程，遇到矛盾怎么处理
平时怎么学习的
为什么选择学习这方面知识
职业规划
你有什么优点（与众不同的东西）
你有什么缺点（别傻傻的光说缺点，说说你是怎么克服，或者绕开它们的呀）
兴趣爱好
平时作息时间
```