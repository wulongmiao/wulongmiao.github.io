---
layout: post
title: vue3
date:  2021-12-10
categories: 前端
tags: [前端开发,vue3]
---

## Composition API 

Vue2 模板随着组件功能越来越多，代码量越来越大，每个功能模块的代码会散落分布在各个位置，让整个项目的内容难以阅读和维护
Vue3 根据逻辑功能来进行组织，提高可维护性，可读性，重用代码，vue2用mixins重用逻辑代码，容易产生冲突，所以 Composition API 又被称为基于函数组合的API

## setup

组合式api的入口，在beforeCreate前调用，setup不能使用this，
setup(props,context){}   
props父组件传递给子组件的所有数据，不能使用解构
context:(attrs,slots,emit)

```
setup (props, context) {
    let { attrs, slots, emit } = context;

    // vue3.x 获取组件上的属性
    console.log(attrs.subData);  // 'some other data'

    // vue3.x 获取slot插槽的节点
    console.log(slots.default());

    // vue3.x emit方法(子组件向父组件传递数据)
    function handleClick () {
        emit('subClick', 'vue3.x - this is subData');
    }

    return { handleClick }
}
```

## ref、reactive

ref：任意类型（建议基本类型）数据的响应式引用（设置、获取值时需要加.value）
reactive：只能是复杂类型数据的响应式引用,浅拷贝

```
import { ref, reactive } from 'vue'
let name=1
let a=ref(name)
a.value
let nameObj=reactive({a:1})
let readonlyObj = readonly(nameObj); 
nameObj.a
```

## toRef 与 toRefs

toRef：用来给抽离响应式对象中的某一个属性，并把该属性包裹成 ref 对象，使其和原对象产生链接。
toRef 的本质是引用，修改响应式数据会影响原始数据。
toRefs：用来把响应式对象转换成普通对象，把对象中的每一个属性，包裹成 ref 对象。

```
import { toRef, toRefs, reactive } from 'vue'
let names=reactive({
    name:'老谭',
    age:23,
    job:{
    salary:10
    }
})
return {
name:toRef(names,'name'),
age:toRef(names,'age'),
salary:toRef(names.job,'salary')
...toRefs(names)
}
```
 
## computed、watch、watchEffect

```
const addCount = computed(() => {
    return num.value * 2;
})		

watch(name, (newVal, oldVal) => {
    console.log(newVal, oldVal);
}, { immediate: true }) // 立即执行
//复杂数据
watch(() => nameObj, (newVal, oldVal) => {
    console.log(newVal, oldVal); // newVal、oldVal具有响应式
}, { deep: true,immediate: true})
// 同时监听多个对象
watch([() => nameObj.name, () => nameObj.lastName], ([newName, newLastName], [oldName, oldLastName]) => {
    console.log(newName, oldName, newLastName, oldLastName);
})

//1.立即执行、立即监听（immediate）
//2.自动会感知代码依赖（自动收集依赖），不需要传递监听的内容（不需要像 watch 一样手动传入依赖）
//3.无法获得变化前的值（oldVal）
const stop = watchEffect(() => {
    console.log(name);
    console.log(nameObj.name);
})
stop()//停止监听
```