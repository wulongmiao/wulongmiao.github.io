---
layout: post
title: vue3
date:  2021-12-10
categories: 前端
tags: [前端开发,vue3]
---

## Composition API 

Vue2 模板随着组件功能越来越多，代码量越来越大，每个功能模块的代码会散落分布在各个位置，让整个项目的内容难以阅读和维护
Vue3 根据逻辑功能来进行组织，提高可维护性，可读性，重用代码，vue2用mixins重用逻辑代码，容易产生冲突，所以 Composition API 又被称为基于函数组合的API

## 全局API



## setup

组合式api的入口，在beforeCreate前调用，setup不能使用this，
setup(props,context){}   
props父组件传递给子组件的所有数据，不能使用解构
context:(attrs,slots,emit)

```
setup (props, context) {
    let { attrs, slots, emit } = context;

    // vue3.x 获取组件上的属性
    console.log(attrs.subData);  // 'some other data'

    // vue3.x 获取slot插槽的节点
    console.log(slots.default());

    // vue3.x emit方法(子组件向父组件传递数据)
    function handleClick () {
        emit('subClick', 'vue3.x - this is subData');
    }

    return { handleClick }
}
```

## ref、reactive

ref：任意类型（建议基本类型）数据的响应式引用（设置、获取值时需要加.value）
reactive：只能是复杂类型数据的响应式引用,浅拷贝

```
import { ref, reactive } from 'vue'
let name=1
let a=ref(name)
a.value
let nameObj=reactive({a:1})
let readonlyObj = readonly(nameObj); 
nameObj.a
```

## toRef 与 toRefs

<pre>
toRef：用来给抽离响应式对象中的某一个属性，并把该属性包裹成 ref 对象，使其和原对象产生链接。
toRef 的本质是引用，修改响应式数据会影响原始数据。
toRefs：用来把响应式对象转换成普通对象，把对象中的每一个属性，包裹成 ref 对象。
</pre>

```
import { toRef, toRefs, reactive } from 'vue'
let names=reactive({
    name:'老谭',
    age:23,
    job:{
    salary:10
    }
})
return {
name:toRef(names,'name'),
age:toRef(names,'age'),
salary:toRef(names.job,'salary')
...toRefs(names)
}
```
 
## computed、watch、watchEffect

```
//computed
const addCount = computed(() => {
    return num.value * 2;
})		
//watch
watch(name, (newVal, oldVal) => {
    console.log(newVal, oldVal);
}, { immediate: true }) // 立即执行
//监听复杂数据
watch(() => nameObj, (newVal, oldVal) => {
    console.log(newVal, oldVal); // newVal、oldVal具有响应式
}, { deep: true,immediate: true})
// 同时监听多个对象
watch([() => nameObj.name, () => nameObj.lastName], ([newName, newLastName], [oldName, oldLastName]) => {
    console.log(newName, oldName, newLastName, oldLastName);
})

//1.立即执行、立即监听（immediate）
//2.自动会感知代码依赖（自动收集依赖），不需要传递监听的内容（不需要像 watch 一样手动传入依赖）
//3.无法获得变化前的值（oldVal）
const stop = watchEffect(() => {
    console.log(name);
    console.log(nameObj.name);
})
stop()//停止监听
```

## 获得dom节点

```
setup () {
    const hello = ref(null); // 获取组件中ref="hello"的真实dom元素
    
    onMounted(() => {
        console.log(hello.value); // <input type="text">
        console.log(hello.value.value); // 张三
    })
    
    return { hello }
}
```

## provide 与 inject

==react context

```
父组件
setup () {
    const name = ref('张三');

    // provide(别名, 要传递的数据和方法)
    provide('myName', name)
    provide('handleClick', () => {
        name.value = 'zhangsan';
    })

},
子组件
setup () {
    //调用 inject 方法，通过指定的别名，接收到父级共享的数据和方法
    const name = inject('myName');
    const handleClick = inject('handleClick');

    return { name, handleClick }
}
```

## teleport

```
<template>
	<router-view />
	<div id="model"></div> <!-- 挂载点 -->
</template>

<template>
	<teleport to="#model"> 
		<!-- 挂载内容 -->
		<div>title</div>
        <div>I'am a Dialog.</div>
	</teleport>
</template>
```

## router

```

```


## suspense、Fragment
