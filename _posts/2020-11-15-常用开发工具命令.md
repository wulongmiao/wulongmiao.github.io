---
layout: post
title: 常用开发工具命令
date: 2020-11-15
categories: 前端
tags: [前端开发, git, linux, vim, nginx, docker]
---

## git

> git:分布式的(每一个开发者在本地克隆一个存储库,最后合并),不需要联网就可以本地看到不同版本,内容按元数据方式存储,鼓励分支

> svn:非分布式,按文件存储,需要联网查看不同版本,分支在SVN中就是版本库中的另外的一个目录

```
查看git全局配置 git config --global  --list

修改全局配置
git config --global user.name "用户名"
git config --global user.email "用户邮箱"

版本回退
git reset --hard HEAD^ 回退到上个版本
git reset --hard HEAD~num 回退到num次提交前的版本
git reset --hard 版本号
git reset --soft 软回滚(回滚指定版本之前的提交记录，对应代码保存到暂存区，生成最新提交替换之前的记录和代码，一般用于相同功能的提交记录规范)
git revert 版本号 (回滚自己的提交，只撤销回滚的版本号，之后的提交记录会保存，生成一条新的提交记录)

初始化远端库 git clone name
创建存储库 git init
查看远程库 git remote -v(详细信息)
推送到远程库 git push -u(第一次推送时需要) origin master(推送master分支) --force(-f)
创建SSH-KEY  ssh-keygen -t rsa –C "youremail@example.com"
添加到暂存区 git add name
提交 git commit -m '添加注释'


指定提交组合成一个新的分支 git cherry-pick name1 name2 (a..b] [a^..b]
创建分支 git checkout(切换到这个分支)  -b(创建) name tagName
查看(新增)分支 git branch name
删除分支 git branch -d name
合并冲突(先从远端拉取代码) git pull
合并分支 git merge name
取消合并 git merge --abort
变基 git rebase
取消变基 git rebase --abort


git标签
创建本地tag     git tag -a <tagName> -m '提交额外信息'
推送到远程仓库  git push origin <tagName>
推送本地所有标签    git push --tags
本地分支标签删除    git tag -d <tagName>
远程库标签删除  git push origin :refs/tags/<tagName>


贮存代码
git stash   暂存缓存区代码
git stash pop   恢复缓存区最后一个元素代码
git stash apply name  恢复指定贮存区代码
git stash list  查看贮存区
```

## vim

```
vim name 打开文件
u 撤销上一步操作
i 进入插入模式
o 当前行后插入一行
Esc 退出插入模式
:w 保存文件
:q 退出 Vim
:q! 强制退出 Vim，不保存更改
:wq 保存文件并退出 Vim
:set nu 显示行号
:set nonu 隐藏行号
:/keyword 在文件中查找关键字
yy 复制当前行
p 粘贴复制的内容
dd 删除当前行
Ctrl + r 重做上一步被撤销的操作
```

## linux

```
scp username@remote:/path/to/remote/directory /path/to/local/file   scp 远程路径 本地路径(下载服务器文件)
scp /path/to/local/file username@remote:/path/to/remote/directory scp 本地路径 远程路径 (上传到服务器)
sftp username@remote_host
get 下载的文件 本地路径
put 上传文件 远程路径

wget 下载文件
wput 本地文件 远程路径

zip name.zip *.jsx 压缩
sz aaa.zip 下载到本地

tail -f -n -100 /path/to/local/file 追踪文件最后100行实时变化
grep -C(匹配前后) -A(匹配后) -B(匹配前) 10(行数) searchContent /path/to/to

cut -d '-' -f7 按-作为分隔符提取每行的第7个字段
sort -nr 排序，默认字典升序, -r降序 -n按数值排序
ps -ef  top 查看资源
uniq -c 相邻的行去重，计算重复的行数

sudo 管理员权限
ls -a列出目录所有文件  ls -l
pwd查看当前路径
cd跳到指定目录
mkdir创建文件夹 fileName
rm删除文件 -f(强制删除) -i(逐一询问) -r(删除子目录) -v(显示结果) fileName
echo 'content' >a.txt  覆盖写入
echo 'content' >>a.txt  文件追加写入
echo 'content' 打印内容
cat fileName 查看文件
mv移动文件或者重命名 fileName ../aa/
cp原文件复制到目标文件a->b a.txt b.txt

包管理yum:
yum install [package_name]: 安装指定的软件包。
yum update [package_name]: 更新指定的软件包。
yum remove [package_name]: 删除指定的软件包。
yum search [keyword]: 在可用的软件包中搜索包含指定关键字的软件包。
yum list: 列出所有已安装的软件包。
yum info [package_name]: 显示指定软件包的详细信息。
yum clean all: 清理yum缓存。
yum repolist: 列出所有可用的软件源。
yum check-update: 检查是否有可用的软件包更新。
yum upgrade: 升级所有可用的软件包。
```

## nginx

nginx命令
```
nginx -s reopen  重启Nginx
nginx -s reload  重新加载配置文件，优雅重启 推荐使用
nginx -s stop  强制停止
nginx -s quit  安全退出
nginx -t  检测配置文件地址 以及检测配置是否正常
nginx -v  显示版本信息并退出
killall nginx  杀死所有nginx进程
```

nginx常用配置
```
server {
    listen 443 ssl;
    server_name   chat.jiangly.com; // https协议证书配置
    ssl_certificate conf.d/chat.jiangly.com_ssl/1_chat.jiangly.com_bundle.crt;
    ssl_certificate_key conf.d/chat.jiangly.com_ssl/2_chat.jiangly.com.key;
    ssl_session_timeout 5m;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
    ssl_prefer_server_ciphers on;
    gzip on;                     #开启gzip压缩功能
    gzip_min_length 10k;         #设置允许压缩的页面最小字节数; 这里表示如果文件小于10个字节，就不用压缩，因为没有意义，本来就很小.
    gzip_buffers 4 16k;          #设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存
    gzip_http_version 1.1;       #压缩版本
    gzip_comp_level 2;           #设置压缩比率，一般折中为6
    gzip_types text/css text/xml application/javascript;      #制定压缩的类型,线上配置时尽可能配置多的压缩类型!
    gzip_disable "MSIE [1-6]\.";       #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）
    location / {
        proxy_pass   http://127.0.0.1:7000; // 反向代理配置
        proxy_set_header X-Forwarded-For $remote_addr;
        add_header Content-type charset=utf-8;
        root html;
        try_files $uri $uri/ @router;
        index  index.html index.htm;
    }
    location @router {
    rewrite ^.*$ /index.html last; // 正则匹配,重定向，last标志表示停止处理其他rewrite规则，该规则优先级最高
    }
    location ~* .(?:css(.map)?|js(.map)?|gif|svg|jfif|ico|cur|heic|webp|tiff?|mp3|m4a|aac|ogg|midi?|wav|mp4|mov|webm|mpe?g|avi|ogv|flv|wmv)$ {
        # 静态资源设置七天强缓存
        expires 7d;
        access_log off;
    }
}

// 负载均衡
http {
    upstream backend {
    # 哈希算法，自动定位到该服务器 保证唯一ip定位到同一部机器 用于解决session登录态的问题
    ip_hash;
    server 127.0.0.1:9090 down; (down 表示单前的server暂时不参与负载)
    server 127.0.0.1:8080 weight=2; (weight 默认为1.weight越大，负载的权重就越大)
    server 127.0.0.1:6060; (默认权重1)
    server 127.0.0.1:6060 fail_timeout=60s max_fails=2; (两次请求失败触发存活机制,60s内所有请求不转发给这台机器)
    server 127.0.0.1:7070 backup; (其它所有的非backup机器down或者忙的时候，请求backup机器)
    }

    server {
        listen 80;
        server_name example.com;

        location / {
            proxy_pass http://backend; // 转发
        }
    }
}
```

## docker

> 镜像->安装包,容器->应用,数据卷-> 本地数据

常用命令
```
docker pull name:tag_name   云端拉取镜像，默认标签latest
docker logs container_Id    查看应用日志
docker search name  查看远端相关镜像name
docker info     查看docker配置
docker version  查看docker版本
docker ps (-a)  查看运行中的容器
docker images   查看本地镜像
docker port CONTAINER_ID 80 查看指定容器端口映射的宿主机端口
docker stats name   查看容器占用系统资源
docker export  CONTAINER_ID > ubuntu.tar 导出本地容器快照
docker export  CONTAINER_ID > ubuntu.tar 导入容器快照(url网址、本地目录)
docker build -t name1:sdd -f bbb.Dockerfile
docker volume 管理数据卷
docker start    启动一个已经停止的容器
docker stop 停止一个容器
docker rm   删除一个容器
docker inspect 查看容器详情

docker run --name some-nqinx -v /some/content:/usr/share/nginx/html:ro 容器只读文件 -d -p 8000:8001

启动参数配置:
-d  后台方式运行(不把执行命令的结果输出在当前宿主机下)
-p宿主机端口8000映到容器端口8001,通过8000端口访问    ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort
-v  指定数据卷
-e  指定环境变量 KEY11=VALUE11
--name 容器名称
:ro 只读
:rw 读写

docker内执行命令:
docker exec -it contain_id /bash/cc
exit // 退出
```

#### docker file

```
from node:last
workspace ../ss
copy . .
volume ./data
run pnpm install vue
cmd []

FROM：基于一个基础镜像来修改
WORKDIR：指定当前工作目录
COPY：把容器外的内容复制到容器内
EXPOSE：指定要暴露的端口
RUN：在容器内执行命令
volume: 自定义数据卷
CMD：容器启动的时候执行的命令
```

#### docker compose
>一个方便维护多个容器的yaml文件，docker认为一个容器对应一个进程，但一个应用会有多个进程，例如上面的mysql和wordpress。

配置文件规则
```
version: // docker compose版本号
services:
  service1:
    image: name
    // service1为我们自定义的服务名称，而image则是对应的镜像文件名或者id,如果我们定义了一个没有的镜像，会自动帮我们拉取下载。
    build: /path/a/b
    // 指定 Dockerfile 所在文件夹的路径。利用它自动构建镜像，然后使用这个镜像启动服务容器。
    command: bundle exec thin -p 3000
    // 容器启动后默认执行的命令
    container_name: xino
    // 自定义容器名称
    depends_on: redis
    // 定义依赖容器，将在定义后的容器后启动
    env_file: - ./common.env
    // 定义环境变量文件路径
    environment:
    - MYSQL_ROOT_PASSWORD=secret
    // 定义环境变量
    port:
    // 端口号
    volumes:
    // 数据卷
    restart: always
    // 重启参数
volumes:
network:
configs:
```

常用命令
```
1. 基于docker-compose.yml启动管理的容器
docker-compose up -d

2. 关闭并删除容器
docker-compose down

3. 开启|关闭|重启已经存在的由docker-compose维护的容器
docker-compose start|stop|restart

4. 查看由docker-compose管理的容器
docker-compose ps

5. 查看日志
docker-compose logs -f
```


#### 其他

##### 远程连接

连接远程机器

> 登录方式： 用户名  密码、公钥、证书

```
本地生成 pubKey privateKey ， 公钥加密，私钥解密数据

私钥 -> 数据，公钥，身份信息 一起散列计算，生成签名
公钥 -> 上传到服务器，验证签名

保证签名可信，一般ca签发证书(包含公钥，持有者信息，持有者数字签名，机构签名)
```

window远程桌面


##### 刷新dns

window

`ipconfig /flushdns`

ios/linux

`sudo killall -HUP mDNSResponder`

##### window命令

```
rmdir /s /q folder  删除文件夹
netstat -ano | findstr :12018 查看指定端口占用进程
tasklist  运行的进程
taskkill /F /PID 30480  停止进程
```
