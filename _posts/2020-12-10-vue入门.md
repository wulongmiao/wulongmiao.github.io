---
layout: post
title: vue入门
date:  2020-12-10
categories: 前端
tags: [前端开发,vue]
---

## vue安装
```
js脚本
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>

npm安装
npm install vue
npm install -g vue-cli
```

## 创建项目

`vue init webpack(webpack-simple) projct_name`
`npm install`
`npm run `

## 组件间传值

获得dom节点template: ref script: $refs
```
父子组件传值:

父组件传给子组件：
父组件 v-bind
子组件 prop

子组件获得父组件数据：
父组件  $children
子组件 this.$parent.attribute

子组件传给父组件：
父组件 定义自定义事件:myevent
子组件 $emit(myevent,data)

父组件获得子组件数据：
子组件实例定义 ref='a'
父组件 this.#refs.a.attribute


非父子组件传值(同一个树结构):
广播
发送方 $emit('name',data)
接收方 $on(name,function(data){})


不在同一颗树(router动态挂载)
localStorage
sessionStorage
vuex
state自定义变量，不可以直接修改里面的数据
$store.state.attribute
getter相当于计算属性，主要用来过滤一些数据
$store.getters.attribute
mutations相当于方法，同步
$store.commit('function')
action可以包含异步方法
$store.dispatch('function')

mapState
mapGetters
mapActions 
```

## 请求数据
```
vue-resource vue官方提供的数据请求插件
`npm install vue-resourse --save`
this.$http.get().then()

jsonp请求
this.$http.jsonp().then()

axios请求
npm install axios --save

axios.post('url')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });

function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // 两个请求现在都执行完成
  }));
配置请求
axios({
  method: 'post',
  url: '/user/12345',
  baseURL:
  timeout:
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
})

拦截器：请求或响应被 then 或 catch 处理前拦截它们
const myInterceptor = axios.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

## 路由

```
get传值：$route.query       /content

动态路由传值:$route.params  /content/:newid


js路由跳转：
this.$router. push({path:'news'})
js命名路由跳转:
this.$router. push({name:'news'})


路由模式

router实例
mode:''
hash模式 #
history模式
```

## vue面试

vue核心
```
数据驱动(双向绑定)
组件
```

双向绑定原理
```
发布者模式+数据劫持监听Object.defineProperty()
```

生命周期(组件,实例)
```
创建：页面创建后执行beforeCreate，初始化，然后执行created函数，可以使用vm本身的属性和方法
挂载：执行beforeMount(可以更改数据，不会触发updated)，虚拟dom放入到render函数中准备渲染，执行mounted,渲染出真实dom
更新：当组件或实例的数据更改之后，会立即执行beforeUpdate，虚拟DOM放入render函数中重新渲染，更新完成后，执行updated，重新渲染真实dom
销毁：beforeDestroy还可以操作实例  destroyed
```

vue优化
```
代码优化:
v-for v-if避免同时使用，for优先级高，浪费性能
v-if 只有满足条件才渲染，有更高的切换开销，v-show 不管是否满足条件，都会被渲染，只是切换display，有更高的初始化开销
computed有缓存，只有变化时才重新计算  watch每当数据变化时执行
当组件数据不会变化仅用于展示，应该阻止vue劫持监听，object.freeze
```

key的作用
```
唯一标识元素，满足重新渲染的需求(不再复用元素)，主要是为了高效更新虚拟dom
```