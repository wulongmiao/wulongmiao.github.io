---
layout: post
title: vue入门
date:  2020-12-10
categories: 前端
tags: [前端开发,vue]
---

## vue安装
```
js脚本
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>

npm安装
npm install vue
npm install -g vue-cli
```

## 创建项目

`vue init webpack(webpack-simple) projct_name`
`npm install`
`npm run `

## 组件间传值

获得dom节点template: ref script: $refs
```
父子组件传值:

父组件传给子组件：
父组件 v-bind:a='aa'
子组件 prop:[a]

子组件获得父组件数据：
父组件  $children
子组件 this.$parent.attribute

子组件传给父组件：
父组件 定义自定义事件:myevent_name
子组件 $emit(myevent_name,data)

父组件获得子组件数据：
子组件实例定义 ref='a'
父组件 this.$refs.a.attribute


非父子组件传值(同一个树结构):
广播(事件中心)
新建vue实例，创建js文件 newVue.js
vue中引用文件 import new from '../newVue.js'
发送方 new.$emit('name',data)
接收方 new.$on(name,function(data){})


不在同一颗树(router动态挂载)
localStorage
sessionStorage

vuex
state自定义变量，不可以直接修改里面的数据
$store.state.attribute
getter相当于计算属性，主要用来过滤一些数据
$store.getters.attribute
mutations相当于方法，同步
$store.commit('function')
action可以包含异步方法
$store.dispatch('function')

辅助函数：
mapState{
  get_state:(state)=>{}
}
mapGetters{
  get_state:(state,other_getters)=>{}
}
mapMutations{
  get_state:(state,param)=>{}
}
mapActions{
// store 实例具有相同方法和属性的 context 对象
 
}
```

## 插槽

```
<slot>默认内容</slot>
匿名插槽：   v-slot:default

v-slot   缩写#    
具名插槽:带有命名name
child:<slot name='a'>默认内容</slot><slot name='b'>默认内容</slot>
parent:<template v-slot='a'></template><template v-slot='b'></template>

作用域插槽：子组件传值给父组件
child:<slot :data='message'>默认内容</slot>
parent:<template v-slot:default="a">{{a.message.username}}</template>

```

## 请求数据
```
vue-resource vue官方提供的数据请求插件
`npm install vue-resourse --save`
this.$http.get().then()

jsonp请求
this.$http.jsonp().then()

axios请求
npm install axios --save

axios.post('url')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
//axios并发请求
function aa() {
  return axios.get('/user/12345');
}
function bb() {
  return axios.get('/user/12345/permissions');
}
axios.all([aa(), bb()])
  .then(axios.spread(function (acct, perms) {
    // 两个请求现在都执行完成
  }));

拦截器：请求或响应被 then 或 catch 处理前拦截它们
//请求拦截器
const myInterceptor = axios.interceptors.request.use(function(config){},function(error){});
//取消拦截器
axios.interceptors.request.eject(myInterceptor);
//响应拦截器
axios.interceptors.response.use(function (response) {},function(error){})
```

## 路由

```
<route-link to=""></route-link>
<route-view></route-view>
<keep-alive></keep-alive>

get传值(url ?)：$route.query       router文件配置： /content      /content?att=value

动态路由传值:$route.params                      /content/:newid      /content/value

函数式路由跳转：
this.$router.push({path:'news'})
js命名路由跳转:
this.$router.push({name:'news'})


路由模式

new router{
mode:''
hash模式 #
history模式
}
```

权限控制

路由拦截
```
 @/router/index.js
{
     path: '/a',
     name: 'a',
     component:	A,
     meta : {                      //加一个自定义obj
   			requireAuth:true      //这个参数 true 代表需要登录才能进入A
     }
   }
/*to: Route: 即将要进入的目标 路由对象
from: Route: 当前导航正要离开的路由
next: Function: 跳转页面
*/
import store from '@/assets/store'   //把这个userId获取过来
router.beforeEach((to,from,next)=>{
	if(to.meta.requireAuth){
		if(store.state.userId){
			next()
		}else{
			next({path:'/b'})
		}
	}else{
		next()
	}
})
router.beforeEach((to, from, next) => {
    //权限校验
    let pass = valid(to);
    if(!pass){
        return console.log('无权访问');
    }
    next();
});
```

用菜单权限筛选出可用路由，再用可用路由初始化Vue应用
```
// 实例化Login类并初始化
  new Login(function (err, data) {
    if (err) {
      // 登录出错
    } else {
      // 登录成功
      init(data);
    }
  }).init();

const init = function (data) {
  // 先配置路由信息
  // componentConfigs 是本地的组件配置
  let routers = assignRouter(data.menus, componentConfigs);
  // 实例化路由
  router = new Router({routes: routers});
  // 再实例化vue
  new Vue({
    el: '#app',
    store,
    router,
    nprogress,
    ...App
  });
};
```