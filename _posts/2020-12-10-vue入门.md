---
layout: post
title: vue入门
date:  2020-12-10
categories: 前端
tags: [前端开发,vue]
---

## vue安装
```
js脚本
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>

npm安装
npm install vue
npm install -g vue-cli
```

## 创建项目

`vue init webpack(webpack-simple) projct_name`
`npm install`
`npm run `

## 组件传值
获得dom节点template: ref script: $refs
```
父子组件传值:

父组件传给子组件：
父组件 v-bind
子组件 prop

子组件获得父组件数据：
父组件  $children
子组件 this.$parent.attribute

子组件传给父组件：
父组件 定义自定义事件:myevent
子组件 $emit(myevent,data)

父组件获得子组件数据：
子组件实例定义 ref='a'
父组件 this.#refs.a.attribute


非父子组件传值(同一个树结构):
广播
发送方 $emit('name',data)
接收方 $on(name,function(data){})


不在同一颗树(router动态挂载)
localStorage
sessionStorage
vuex
state自定义变量，不可以直接修改里面的数据
getter相当于计算属性，主要用来过滤一些数据
mutations相当于方法，同步
action可以包含异步方法
```

## 请求数据
```
vue-resource vue官方提供的数据请求插件
npm install vue-resourse --save
this.$http.get().then()

jsonp请求
this.$http.jsonp().then()

axios
npm install axios --save
```

## 路由

```
get传值：$route.query       /content

动态路由传值:$route.params  /content/:newid


js跳转路由：
this.$router. push({path:'news'})
命名路由跳转
this.$router. push({name:'news'})


路由模式

vueter实例
mode:''
hash模式 #
history模式

```



## vue面试

vue核心
```
数据驱动(双向绑定)
组件
```

参数传递
```
1.父组件与子组件传值
父组件传给子组件：子组件通过props方法接受数据$event===data;
子组件传给父组件：$emit(自定义事件,data)方法传递参数

2.非父子组件间的数据传递，兄弟组件传值
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件
```

vuex
```
没有关联的组件数据共享，相当于公共仓库，保持所有组件的共用数据
state自定义变量，不可以直接修改里面的数据
mutations相当于方法，同步
getter相当于计算属性，主要用来过滤一些数据
action可以包含异步方法
```

双向绑定原理
```
发布者模式+数据劫持监听Object.defineProperty()
```

生命周期(组件,实例)
```
创建：页面创建后执行beforeCreate，初始化，然后执行created函数，可以使用vm本身的属性和方法
挂载：执行beforeMount(可以更改数据，不会触发updated)，虚拟dom放入到render函数中准备渲染，执行mounted,渲染出真实dom
更新：当组件或实例的数据更改之后，会立即执行beforeUpdate，虚拟DOM放入render函数中重新渲染，更新完成后，执行updated，重新渲染真实dom
销毁：beforeDestroy还可以操作实例  destroyed
```

mvvm和mvc
```
mvc:view传送命令到controller完成业务逻辑要求model改变状态model将新的数据发送给view，用户得到反馈	
mvvm:数据解析交给vm做，弱化c，view 和 model不能直接交互,view model 通过viewmodel交互，m通过数据绑定将后台数据转化成v，v通过事件监听将页面转化成m,实现view和model双向绑定,自动同步数据不需要操作dom
```

Vue的路由实现：hash模式 和 history模式
```
hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；
特点：不被包括在HTTP请求中；对服务端安全无用，hash不会重加载页面

history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更
```

vue路由的钩子函数
```
首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。
beforeEach主要有3个参数to，from，next：
to：route即将进入的目标路由对象，
from：route当前导航正要离开的路由
next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。
```

vue单页面应用及其优缺点
```
优点：核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好
缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退
```

vue常用的修饰符
```
.prevent: 提交事件不再重载页面；
.stop: 阻止单击事件冒泡；
.self: 当事件发生在该元素本身而不是子元素的时候会触发；
.capture: 事件侦听，事件发生的时候会调用
```

vue优化
```
代码优化:
v-for v-if避免同时使用，for优先级高，浪费性能
v-if 只有满足条件才渲染，有更高的切换开销，v-show 不管是否满足条件，都会被渲染，只是切换display，有更高的初始化开销
computed有缓存，只有变化时才重新计算  watch每当数据变化时执行
当组件数据不会变化仅用于展示，应该阻止vue劫持监听，object.freeze
```

key的作用
```
唯一标识元素，满足重新渲染的需求(不再复用元素)，主要是为了高效更新虚拟dom
```

keep-alive
```
keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染
```