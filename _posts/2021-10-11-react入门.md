---
layout: post
title: react入门
date: 2021-10-11
categories: 前端
tags: [前端开发, react]
---

## react 项目构建

webpack
`npx create-react-app my-app`
vite
`yarn create @vitejs/app my-app`
`npm init @vitejs/app my-vue-app`

## react

state

```
this.state
setState()
```

props==vue prop

```
this.prop.ParentAttributes
```

hook
必须在最外层函数(组件)使用

```
state hook
const [state, setState] =useState(初始值)

effect hook
useEffect(){

}

自定义hook
可以使用其他hook
useMyEffect(){

}
```

context

```
发送
export const MyContext = React.createContext(defaultValue);
<MyContext.Provider value={/* 某个值 */}>
接收
import { MyContext } from "../index";
MyContext.Consumer._currentValue;


发送
import {useContext,createContext} from 'react'
const MyContext = createContext(defaultValue);
<MyContext.Provider value={/* 某个值 */}>
</MyContext.Provider>
接收
useContext(MyContext)

```

refs
```
// 传递refs
myRef = useRef(null)
const node = myRef.current;
  render() {
    return <div ref={myRef} />;
  }
```

## react-router-dom

`npm install react-router-dom@6 --save-dev`

基本使用
```
HashRouter hash模式
BrowserRouter 历史模式

import {  BrowserRouter } from 'react-router-dom';
<BrowserRouter>
        <Routes>
          <Route path="/" element={<Home />}></Route>
          <Route path="/about" element={<About />}></Route>
        </Routes>
</BrowserRouter>
```

嵌套路由
```
<Routes>
  <Route path="user" element={<Users />}>
    <Route path=":id" element={<UserDetail />} />
    <Route path="create" element={<NewUser />} />
  </Route>
</Routes>

import  { useRoutes } from 'react-router-dom'
function App() {
  const element = useRoutes([
    {
      path: '/',
      element: <Layout />,
      children: [
        {
          path: 'auth/*',
          element: <Auth/>
        },
        {
          path: 'basic/*',
          element: <Basic/>
        }
      ]
    }
  ])
  return (
     {element}
  )
}


访问 /user/123,渲染成
<Users>
    <UserDetail/>
</Users>

访问/user/create,渲染成
<Users>
    <NewUser/>
</Users>
```

重定向
```
<Route path="*" element={<Navigate to="/home" />} />
```

获取参数
```
params
Route path="/list/:id" component={List}
<Link to="/list/2" >跳转页面</Link>
this.props.history.push("/list/2");
//读取参数：this.props.match.params.id
let params = useParams();

search
<Route path='/web/departManange ' component={DepartManange}/>
<link to="web/departManange?tenantId=12121212">xxx</Link>
this.props.history.push({pathname:"/web/departManange?tenantId" + row.tenantId});
读取参数用: this.props.location.search
let [searchParams, setSearchParams] = useSearchParams();

state
<Route path='/sort ' component={Sort}/>
<Link to={{ path : '/sort ' , state :  name : 'sunny' }}>
this.props.history.push({pathname:"/sort ",state : { name : 'sunny' }});
//读取参数: this.props.location.query.state;

query
<Route path='/query' component={Query}/>
<Link to={{ path : '/query' , query :  name : 'sunny' }}>
this.props.history.push({pathname:"/query",query: { name : 'sunny' }});
读取参数用: this.props.location.query.name
```

编程式导航useNavigate
```
旧hooks useHistory
import { useHistory } from 'react-router-dom';
let history = useHistory();
history.push('/home','sada');
history.replace('/home',{test:'aaa'});

新hooks useNavigate
let navigate = useNavigate();
function handleClick() {
 navigate("/manageData",{state:{value:111}});
 navigate('/home', {replace: true});
}
<button onClick={() => navigate(-2)}>
```

## redux(~=vuex)

（1）Web 应用是一个状态机，视图与状态是一一对应的。
（2）所有的状态，保存在一个对象里面。
创建 redux 中心

```
import { createStore } from 'redux';
const store = createStore(fn)
```

state

```
import { createStore } from 'redux';
const store = createStore(fn)
store.getState();
```

action

```
import { createStore } from 'redux';
const store = createStore(fn)
const action = {
  type: 'action_name',
  payload: '携带信息'
};
//生成多个action
function create_action(){
    return {
  type: 'action_name',
  payload: '携带信息'
};
}
const action = create_action();
```

dispatch
发出 action

```
import { createStore } from 'redux';
const store = createStore(fn);
//接收一个action
store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});
```

Reducer
改变 state 的计算过程，纯函数，不能改写参数
返回新的 state,dispatch 自动触发 reducer

```
const reducer = function (state, action) {
  // ...
  return new_state;
};
const store = createStore(reducer);
```

subscribe
state 变化，自动调用
store.subscribe 方法返回一个函数，调用这个函数就可以解除监听

```
import { createStore } from 'redux';
const store = createStore(reducer);

let delete=store.subscribe(listener);
detete()
```

多个 reducer 合并

```
import { combineReducers } from 'redux';

const reducer = combineReducers({
  a: doSomethingWithA,
  b: processB,
  c: c
})
```

action 发出后，异步执行 reducer
在发出 action 和执行 reducer 之间，添加功能，中间件

```
import { applyMiddleware, createStore } from 'redux';
//日志中间件
import createLogger from 'redux-logger';
const logger = createLogger();

const store = createStore(
  reducer,
  //applyMiddlewares将所有中间件放入一个数组，依次执行
  applyMiddleware(thunk, promise, logger)
);
```

处理异步操作
同步操作只要发出一种 Action ，异步操作要发出三种 Action
操作发起时的 Action
操作成功时的 Action
操作失败时的 Action

```
// 写法一：名称相同，参数不同
{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: { ... } }

// 写法二：名称不同
{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
```

redux-redux
将所有组件分成两大类：UI 组件（presentational component）和容器组件
UI 组件
只负责 UI 的呈现，不带有任何业务逻辑
没有状态（即不使用 this.state 这个变量）
所有数据都由参数（this.props）提供
不使用任何 Redux 的 API
对于组件需要拆分 UI 和容器组件：外面是一个容器组件，内部是 UI 组件，外部与外部通信，将数据传给 UI
redux 负责自动生成容器组件

connect 方法，用于从 UI 组件生成容器组件

```
import { connect } from 'react-redux'
const VisibleTodoList = connect(
  //负责输入，输出逻辑
  mapStateToProps,
  mapDispatchToProps
  )(TodoList);
//第一个参数是总是state,第二个参数代表容器组件的props对象
const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t => !t.completed)
    default:
      throw new Error('Unknown filter: ' + filter)
  }
}

//函数
const mapDispatchToProps = (
  dispatch,
  ownProps
) => {
  return {
    onClick: () => {
      dispatch({
        type: 'SET_VISIBILITY_FILTER',
        filter: ownProps.filter
      });
    }
  };
}
//对象
const mapDispatchToProps = {
  onClick: (filter) => {
    type: 'SET_VISIBILITY_FILTER',
    filter: filter
  };
}
```

Provider 组件，可以让容器组件拿到 state(context 封装)

```
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp);

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
```
