---
layout: post
title: react入门
date:  2021-10-11
categories: 前端
tags: [前端开发,react]
---

## react项目构建
webpack
`npx create-react-app my-app`
vite
`yarn create @vitejs/app my-app` 
`npm init @vitejs/app my-vue-app` 

## react
state
```
this.state
setState()
```

props==vue prop
```
this.prop.ParentAttributes
```

hook
必须在最外层函数(组件)使用
```
state hook
const [state, setState] =useState(初始值) 

effect hook
useEffect(){
  
} 

自定义hook
可以使用其他hook
useMyEffect(){
  
} 
```

context

```
const MyContext = React.createContext(defaultValue);
<MyContext.Provider value={/* 某个值 */}>

// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。
// 为当前的 theme 创建一个 context（“light”为默认值）。
const ThemeContext = React.createContext('light');
class App extends React.Component {
  render() {
    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。
    // 无论多深，任何组件都能读取这个值。
    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

// 中间的组件再也不必指明往下传递 theme 了。
function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends React.Component {
  // 指定 contextType 读取当前的 theme context。
  // React 会往上找到最近的 theme Provider，然后使用它的值。
  // 在这个例子中，当前的 theme 值为 “dark”。
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}
```

## redux(~=vuex)
（1）Web 应用是一个状态机，视图与状态是一一对应的。
（2）所有的状态，保存在一个对象里面。
创建redux中心
```
import { createStore } from 'redux';
const store = createStore(fn)
```
state
```
import { createStore } from 'redux';
const store = createStore(fn)
store.getState();
```
action
```
import { createStore } from 'redux';
const store = createStore(fn)
const action = {
  type: 'action_name',
  payload: '携带信息'
};
//生成多个action
function create_action(){
    return {
  type: 'action_name',
  payload: '携带信息'
};
}
const action = create_action();
```
dispatch
发出action
```
import { createStore } from 'redux';
const store = createStore(fn);
//接收一个action
store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});
```
Reducer
改变state的计算过程，纯函数，不能改写参数
返回新的state,dispatch自动触发reducer
```
const reducer = function (state, action) {
  // ...
  return new_state;
};
const store = createStore(reducer);
```
subscribe
state变化，自动调用
store.subscribe方法返回一个函数，调用这个函数就可以解除监听
```
import { createStore } from 'redux';
const store = createStore(reducer);

let delete=store.subscribe(listener);
detete()
```
多个reducer合并
```
import { combineReducers } from 'redux';

const reducer = combineReducers({
  a: doSomethingWithA,
  b: processB,
  c: c
})
```



action发出后，异步执行reducer
在发出action和执行reducer之间，添加功能，中间件
```
import { applyMiddleware, createStore } from 'redux';
//日志中间件
import createLogger from 'redux-logger';
const logger = createLogger();

const store = createStore(
  reducer,
  //applyMiddlewares将所有中间件放入一个数组，依次执行
  applyMiddleware(thunk, promise, logger)
);
```
处理异步操作
同步操作只要发出一种 Action ，异步操作要发出三种 Action
操作发起时的 Action
操作成功时的 Action
操作失败时的 Action
```
// 写法一：名称相同，参数不同
{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: { ... } }

// 写法二：名称不同
{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
```




redux-redux
将所有组件分成两大类：UI 组件（presentational component）和容器组件
UI组件
只负责 UI 的呈现，不带有任何业务逻辑
没有状态（即不使用this.state这个变量）
所有数据都由参数（this.props）提供
不使用任何 Redux 的 API
对于组件需要拆分UI和容器组件：外面是一个容器组件，内部是UI组件，外部与外部通信，将数据传给UI
redux负责自动生成容器组件

connect方法，用于从 UI 组件生成容器组件
```
import { connect } from 'react-redux'
const VisibleTodoList = connect( 
  //负责输入，输出逻辑
  mapStateToProps,
  mapDispatchToProps
  )(TodoList);
//第一个参数是总是state,第二个参数代表容器组件的props对象
const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t => !t.completed)
    default:
      throw new Error('Unknown filter: ' + filter)
  }
}  

//函数
const mapDispatchToProps = (
  dispatch,
  ownProps
) => {
  return {
    onClick: () => {
      dispatch({
        type: 'SET_VISIBILITY_FILTER',
        filter: ownProps.filter
      });
    }
  };
}
//对象
const mapDispatchToProps = {
  onClick: (filter) => {
    type: 'SET_VISIBILITY_FILTER',
    filter: filter
  };
}
```

Provider组件，可以让容器组件拿到state(context封装)
```
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp);

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
```

## react-router-dom
`npm install react-router-dom --save-dev`

```
export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a>去detail</a>
                <a href='#/detail'>去detail</a>
            </div>
        )
    }
}

export default class Home extends React.Component {
    render() {
        return (
            <div>
                <a>回到home</a>
                <a href='#/'>回到home</a>           
            </div>
        )
    }
}

import {HashRouter,historyRouter, Route, Switch} from 'react-router-dom';
const BasicRoute = () => (
    <HashRouter>
        <Switch>
            <Route exact path="/" component={Home}/>
            <Route exact path="/detail" component={Detail}/>
        </Switch>
    </HashRouter>
);
```
函数式跳转
```
    render() {
        return (
            <div>
                <Link to={'/demo/'+'6'}>XX</Link>
                <Link to={{pathname:'/demo/'+'6'}}>XX</Link>
                <button onClick={() => this.props.history.push({
                        pathname: '/detail',
                        state: {
                            id: 3
                        }
                })}>通过函数跳转
                </button>
                <button onClick={() => this.props.history.push('detail')}>通过函数跳转</button>
            </div>
        )
    }

import {HashRouter, Route, Switch,hashHistory} from 'react-router-dom';
const BasicRoute = () => (
    <HashRouter history={hashHistory}>
        <Switch>
            <Route exact path="/" component={Home}/>
            //路由传参
            <Route exact path="/detail/:id" component={Detail}/>
            <Route exact path="/detail" component={Detail}/>
        </Switch>
    </HashRouter>
);

获取参数
params
this.props.match.params.attrubite

query
this.props.location.query.attribute

state
this.props.location.state.attribute

```
