---
layout: post
title: react入门
date: 2021-10-11
categories: 前端
tags: [前端开发, react]
---

## react 项目构建

webpack
`npx create-react-app my-app`
vite
`yarn create @vitejs/app my-app`
`npm init @vitejs/app my-vue-app`

## react

state

```
this.state
setState()
```

props==vue prop

```
this.prop.ParentAttributes
```

hook
必须在最外层函数(组件)使用

```
state hook
const [state, setState] =useState(初始值)

effect hook
useEffect(){

}

自定义hook
可以使用其他hook
useMyEffect(){

}
```

context

```
const MyContext = React.createContext(defaultValue);
<MyContext.Provider value={/* 某个值 */}>

// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。
// 为当前的 theme 创建一个 context（“light”为默认值）。
const ThemeContext = React.createContext('light');
class App extends React.Component {
  render() {
    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。
    // 无论多深，任何组件都能读取这个值。
    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

// 中间的组件再也不必指明往下传递 theme 了。
function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends React.Component {
  // 指定 contextType 读取当前的 theme context。
  // React 会往上找到最近的 theme Provider，然后使用它的值。
  // 在这个例子中，当前的 theme 值为 “dark”。
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}
```

## redux(~=vuex)

（1）Web 应用是一个状态机，视图与状态是一一对应的。
（2）所有的状态，保存在一个对象里面。
创建 redux 中心

```
import { createStore } from 'redux';
const store = createStore(fn)
```

state

```
import { createStore } from 'redux';
const store = createStore(fn)
store.getState();
```

action

```
import { createStore } from 'redux';
const store = createStore(fn)
const action = {
  type: 'action_name',
  payload: '携带信息'
};
//生成多个action
function create_action(){
    return {
  type: 'action_name',
  payload: '携带信息'
};
}
const action = create_action();
```

dispatch
发出 action

```
import { createStore } from 'redux';
const store = createStore(fn);
//接收一个action
store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});
```

Reducer
改变 state 的计算过程，纯函数，不能改写参数
返回新的 state,dispatch 自动触发 reducer

```
const reducer = function (state, action) {
  // ...
  return new_state;
};
const store = createStore(reducer);
```

subscribe
state 变化，自动调用
store.subscribe 方法返回一个函数，调用这个函数就可以解除监听

```
import { createStore } from 'redux';
const store = createStore(reducer);

let delete=store.subscribe(listener);
detete()
```

多个 reducer 合并

```
import { combineReducers } from 'redux';

const reducer = combineReducers({
  a: doSomethingWithA,
  b: processB,
  c: c
})
```

action 发出后，异步执行 reducer
在发出 action 和执行 reducer 之间，添加功能，中间件

```
import { applyMiddleware, createStore } from 'redux';
//日志中间件
import createLogger from 'redux-logger';
const logger = createLogger();

const store = createStore(
  reducer,
  //applyMiddlewares将所有中间件放入一个数组，依次执行
  applyMiddleware(thunk, promise, logger)
);
```

处理异步操作
同步操作只要发出一种 Action ，异步操作要发出三种 Action
操作发起时的 Action
操作成功时的 Action
操作失败时的 Action

```
// 写法一：名称相同，参数不同
{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: { ... } }

// 写法二：名称不同
{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
```

redux-redux
将所有组件分成两大类：UI 组件（presentational component）和容器组件
UI 组件
只负责 UI 的呈现，不带有任何业务逻辑
没有状态（即不使用 this.state 这个变量）
所有数据都由参数（this.props）提供
不使用任何 Redux 的 API
对于组件需要拆分 UI 和容器组件：外面是一个容器组件，内部是 UI 组件，外部与外部通信，将数据传给 UI
redux 负责自动生成容器组件

connect 方法，用于从 UI 组件生成容器组件

```
import { connect } from 'react-redux'
const VisibleTodoList = connect(
  //负责输入，输出逻辑
  mapStateToProps,
  mapDispatchToProps
  )(TodoList);
//第一个参数是总是state,第二个参数代表容器组件的props对象
const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t => !t.completed)
    default:
      throw new Error('Unknown filter: ' + filter)
  }
}

//函数
const mapDispatchToProps = (
  dispatch,
  ownProps
) => {
  return {
    onClick: () => {
      dispatch({
        type: 'SET_VISIBILITY_FILTER',
        filter: ownProps.filter
      });
    }
  };
}
//对象
const mapDispatchToProps = {
  onClick: (filter) => {
    type: 'SET_VISIBILITY_FILTER',
    filter: filter
  };
}
```

Provider 组件，可以让容器组件拿到 state(context 封装)

```
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp);

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
```

## react-router-dom

`npm install react-router-dom@6 --save-dev`

基本使用
```
HashRouter hash模式
BrowserRouter 历史模式

import { BrowserRouter } from 'react-router-dom';
<BrowserRouter>
        <Routes>
          <Route path="/" element={<Home />}></Route>
          <Route path="/about" element={<About />}></Route>
        </Routes>
</BrowserRouter>
```

嵌套路由
```
<Routes>
  <Route path="user" element={<Users />}>
    <Route path=":id" element={<UserDetail />} />
    <Route path="create" element={<NewUser />} />
  </Route>
</Routes>

访问 /user/123,渲染成
<Users>
    <UserDetail/>
</Users>

访问/user/create,渲染成
<Users>
    <NewUser/>
</Users>
```

重定向
```
<Route path="*" element={<Navigate to="/home" />} />
```

获取参数
```
 useParams
 useSearchParams  query查询,参数显示在url地址

<Routes>
  <Route path="user" element={<Users />}>
    <Route path=":id" element={<UserDetail />} />
    <Route path="create" element={<NewUser />} />
  </Route>
</Routes>

//UserDetail
import { useParams, useSearchParams } from "react-router-dom";
let params = useParams();
return <h2>User: {params.id}</h2>;

let [searchParams, setSearchParams] = useSearchParams();
searchParams.get("id")
```

useNavigate
```
替代原有V5中的useHistory的新hooks ==vue useRouter
let navigate = useNavigate();
function handleClick() {
  navigate("/home");
}
//组件写法
function App() {
    return <Navigate to="/home" replace state={state} />;
}
<button onClick={() => navigate(-2)}>
```
