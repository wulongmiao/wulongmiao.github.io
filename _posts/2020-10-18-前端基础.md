---
layout: post
title: 前端基础
date:  2021-8-29
categories: 前端
tags: [前端开发,面试]
---
## 目录

<div><a href="#suanfa" target="_self">1. 简单排序算法</a></div>
<div><a href="#web" target="_self">2. html,web基础</a></div>
<div><a href="#csss" target="_self">3. css</a></div>
<div><a href="#jss" target="_self">4. js</a></div>

<div id="suanfa" ></div>

## 简单排序算法

<img src="/img/排序算法.png">

```
冒泡：重复遍历，比较两个元素，判断是否需要交换
选择：在待排序序列中找到最值，放入排序序列起始位置，再从未排序列中找最值，直至待排序列为空           改进可以选出每轮最大和最小
堆排序(交换)：每个节点都大于子节点的值(大堆)，小于则是小堆，交换堆顶和末尾元素重新建堆
快速(冒泡改进)：选定一个元素，将大于这个元素，和小于这个元素分别放入两个序列中，在两个序列中按照这个规则排序
归并：分为两个长度一样的序列，递归排序，最后和并
插入：每一步都将元素插入到排好序的序列中适当位置，直至全部插入
希尔排序(插入)：把数据按增量分成多份，对每一份插入排序，增量减半,直到增量1，基本有序，执行插入排序完成
```

#### 代码
```
//冒泡
	for (int i = 0; i < len - 1; ++i)
	{
		bool exchange = false;
		for (int j = 1; j < len - i; ++j)
		{
			if (arr[j - 1]>arr[j])
			{
				swap(arr[j-1],arr[j]);
				exchange = true;
			}
		}
		if (exchange == false)
		{
			return;
		}
	}


//选择
	for (int i = 0; i < len-1; ++i)
	{
		int k = i;//k保存最小的数
		for (int j =i+1; j < len-1; ++j)
		{
			if (arr[k]>arr[j])
			{
				k=j;
			}
		}
		if (k != i)
		{
			swap(arr[k], arr[i]);
		}
	}


//插入
for(var i=0;i<len;i++){
var key=data[i]; //待插数据
var j=i-1;
while(j>=0 && data[j]>key){
data[j+1]=data[i];
j--;
}
data[j+1]=key;
}


//快排
void _QuickSort1(int *arr,int left,int right)
{
	if (left >= right)
		return;
	int begin = left;
	int end = right - 1;
	int key = arr[right];
	while (begin < end)
	{
		if (begin < end && arr[begin] <= key)//找大
		{
			++begin;
		}
		if (begin < end && arr[end] >= key)//找小
		{
			--end;
		}
		if (begin <end)
		{
			swap(arr[begin], arr[end]);
		}
	}
	if (arr[begin] < key)
	{
		++begin;
	}
	swap(arr[begin], arr[right]);
	// 递归排序子序列
	_QuickSort1(arr, left, begin - 1);
	_QuickSort1(arr,begin + 1,right);
}
```


<div id="web" ></div>

## html,web基础

htMl常用转义字符
```
space空格   &nbsp;
半个中文空格	&ensp;
中文空格	&emsp;
<   &lt;
>	&gt;
&	&amp;
" 	&quot;
'	&apos;
©	&copy;
```

js转义字符
```
\n	换行
\t	tab
\r	回车符
\\	反斜杠
\u unicode编码
```

meta
```
name属性主要用于描述网页，对应属性是 content ，以便于搜索引擎机器人查找、分类

A. keywords(关键字)
说明：用于告诉搜索引擎，你网页的关键字

B. description(网站内容的描述)
说明：用于告诉搜索引擎，你网站的主要内容

C. viewport(移动端的窗口)
<meta name="viewport" content="width=device-width, initial-scale=1">

D. robots(定义搜索引擎爬虫的索引方式)
说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。
具体参数如下：
1.none : 搜索引擎将忽略此网页，等价于noindex，nofollow。
2.noindex : 搜索引擎不索引此网页。
3.nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。
4.all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。
5.index : 搜索引擎索引此网页。
6.follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。

E. author(作者)
说明：用于标注网页作者

F. generator(网页制作软件)
说明：用于标明网页是什么软件做的

G. copyright(版权)
说明：用于标注版权信息

H. revisit-after(搜索引擎爬虫重访时间)
说明：减轻搜索引擎爬虫对服务器带来的压力，设置爬虫的重访时间



http-equiv类似于HTTP的头部协议，它回应给浏览器一些有用的信息，网页内容。与之对应的属性值为content

A. content-Type(设定网页字符集)(推荐使用HTML5的方式)
说明：用于设定网页字符集，便于浏览器解析与渲染页面
<meta http-equiv="content-Type" content="text/html;charset=utf-8">  //旧的HTML，不推荐
<meta charset="utf-8"> //HTML5设定网页字符集的方式，推荐使用UTF-8

B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)
说明：用于告知浏览器以何种版本来渲染页面。
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/> //指定IE和Chrome使用最新版本渲染当前页面

C. cache-control(指定请求和响应遵循的缓存机制)
<meta http-equiv="cache-control" content="no-cache">
共有以下几种用法：
no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。
no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）
public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果
private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）
maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求

D. expires(网页到期时间)
说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。
<meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" />

E. refresh(自动刷新并指向某页面)
说明：网页将在设定的时间内，自动刷新并调向设定的网址。
<meta http-equiv="refresh" content="2；URL=http://www.lxxyx.win/"> //意思是2秒后跳转向我的博客

F. Set-Cookie(cookie设定)
说明：如果网页过期。那么这个网页存在本地的cookies也会被自动删除。
```

Unicode编码
```
万国码：全世界所有的语言、公式、符号
编码范围：0x000000-0x10FFFF  3个字节——24位
UTF-8：通过规则转换后再存储，变字长编码，前0x7f字符与ASCII码兼容
UTF-16：2字节存储，js字符串编码方式
	UTF-16BE大端就是将高位的字节放在低地址表示
	UTF-16LE小端就是将高位的字节放在高地址表示 
UTF-32：使用4个字节存储，直接存码值，很多情况下是浪费内存的

ES6用\u表示unicode-32编码
```

http和https的区别
```
1、http协议：是超文本传输协议，信息是明文传输。80端口  免费申请
2、https协议：具有安全性的ssl/tls加密传输协议。443端口 需要到ca申请证书
```

http1.0,2.0,3.0特性
```
http请求有限制，超过会阻塞线程,延迟高，明文传输，报文数据重复
完全多路复用(解决了线程阻塞的问题)，使用报头压缩，采用二进制协议，服务器推送，https协议
增加了基于UDP的QUIC协议
```

进程和线程
```
进程是竞争计算机资源(分配和管理)的基本单位，是程序执行的实例
线程是进程的一部分，是程序执行的最小单位
```

ajax
```
XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面

new XMLHttpRequest
open("post get","url",true异步)
send("string仅当post时可用")
onreadystatechange
readyState || status
responseText responseXML

(http状态码)status:
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
常见的状态码有101切换协议，200成功，301永久重定向，302临时重定向，304未修改
readystate:
0 － （未初始化）还没有调用send()方法
1 － （载入）已调用send()方法，正在发送请求
2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
3 － （交互）正在解析响应内容
4 － （完成）响应内容解析完成，可以在客户端调用了
```

cookie,session,localStorage区别
```
cookie 以键值对形式保存数据，作为HTTP请求响应的一部分，自定义保存时间，长度和数量的限制4k
sessionstorage 浏览器关闭删除数据5m，安全性高些，不用担心被截取
localStorage 除非用户删除数据5m，否则会一直存在本地，不用担心被截取
session 数据保存在服务器，安全性高，对服务器性能要求更高
```


前端性能优化方法
```
减少http请求
    压缩图片 懒加载  使用精灵图  合并压缩css和js
    利用缓存精简请求(客户端)	
减少域名数 cdn加速
css放在head js放在底部
代码优化:减少对doM的添加，删除操作
```

提高并发
```
利用缓存，精简请求
静态资源上传cdn
避免高频刷新页面获取数据
设置响应头cache-control和last-modified
```

浏览器输入url后发生了什么（HTTP请求过程）
```
DNS域名解析
客户机提出域名解析请求，请求发送给本地的域名服务器。
本地域名服务器查询本地的缓存，如果有该纪录项，本地的域名服务器就直接把查询的结果返回。
如果本地的缓存中没有该纪录，则本地域名服务器就直接把请求发给根域名服务器，根域名服务器再返回给本地域名服务器一个查询域(根的子域) 的主域名服务器的地址。
本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。
本地域名服务器把返回的结果保存到缓存，结果返回给客户机。

根据IP建立TCP连接（三次握手）

发起HTTP请求
请求行(描述客户端的请求方式，url和http协议的版本号)
请求头(客户端的主机和端口,客户端的环境信息)
请求正文(post请求，需要传递的数据传递到这)
简单请求：
head   仅请求响应首部
get 通过url传递，所以传输数据小1024，安全性低，仅查询，不做修改     常用于请求一个资源
post 安全，没有传输限制，可修改   提交表单
非简单请求：
delete 删除  
put 更新   浏览器不支持方法

服务器处理请求，浏览器接收HTTP响应
关闭TCP连接（四次挥手）

渲染页面：
浏览器将获取的HTML文档并解析成DOM树。
css构成层叠样式表模型CSSOM(CSS Object Model)
将DOM和CSSOM合并为渲染树(rendering tree)
浏览器布局 绘制页面

```

强缓存协商缓存
```
直接从本地副本比对读取，不去请求服务器，返回的状态码是 200。
会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。
```

懒加载(延迟加载)
```
先将img标签中的src链接设为同一张图片（空白图片），将真正的图片地址存储自定义属性中
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染，增加服务器负担
```

xss攻击(跨站脚本攻击)
```
注入恶意代码到网页，用户加载并执行    评论功能
危害：盗用cookie
解决：过滤html,js,css标签
```

csrf攻击(跨站请求伪造攻击)
```
攻击者盗用了你的身份，以你的名义发送恶意请求
1.登录受信任网站A，并在本地生成Cookie。
2.在不登出A的情况下，访问危险网站B。
预防：验证码  表单增加伪随机数  
```

同源策略
```
仅同域名，同端口，同协议的网页可以通讯，无法读取非同源网页的 Cookie、LocalStorage，无法向非同源地址发送 AJAX 请求

跨域方法：
1.CORS:关键后端实现
2.postMessage: HTML5 XMLHttpRequest中的API
3.webSocket:实现了浏览器与服务器的全双工通信
4.JSONP:利用javascript可以跨域，仅支持get请求
5.Nginx:搭建一个中转服务器，反向代理实现跨域，支持所有浏览器，并且不会影响服务器性能
```

cdn
```
bootcdn
通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点
就近取得所需的内容，提高用户访问网站的响应速度,加速网页静态资源：图片，媒体，js,css
```

<div id="csss" ></div>

## css

dom对象宽高
```
只读属性
可视区域paddding+content：clientHeight clientWidth
padding+content+boder:offsetHeight offsetWidth
offsetParent:最近的父元素
offsetTop offsetLeft：与最近父元素的top left
scrollHeight scrollWidth:元素宽高，包括卷起的内容，若无=client

可写属性
scrollTop scrollLeft:当前区域卷起的宽高

```

css编写顺序
```
定位属性
自身属性	
文本属性
其他属性
```

前端布局
```
静态布局
    网页外层容器有固定的大小,所有的内容以该容器为标准,超出宽高的部分用滚动条


自适应布局
	屏幕大小改变时，会出现不同的布局，由多个静态布局组成，只改变位置，大小不变


流式布局
	随着屏幕的改变，页面的布局没有发生大的变化，可以进行适配调整，这个正好与自适应布局
相补，元素的大小会变化而位置不会变化
1.两列布局
   两列布局是一侧固定，另一侧自适应。一般一个浮动，另一个设置margin，或者一个绝对定位，另一个设置margin
2.三列布局
   让三列浮动，然后通过负外边距形成三列布局，优先加载中间main
   圣杯布局：利用父容器的左、右内边距定位
   双飞翼布局：把主列嵌套在div后利用主列的左、右外边距定位
<div class="main-wrapper"> 
    <div class="main"></div> 
</div>
<div class="sub"></div> 
<div class="extra"></div> 
.main-wrapper { 
    float: left; 
    width: 100%;
}
.main { 
    height: 300px;
    margin-left: 210px;
    margin-right: 190px;
}
.sub { 
    float: left; 
    width: 200px;
    height: 300px;
    margin-left: -100%;
}
.extra { 
    float: left; 
    width: 180px;
    height: 300px;
    margin-left: -180px;
}

弹性布局 flex
容器属性
flex-flow
flex-direction:row(默认值) column  -reverse
flex-wrap:wrap nowrap(默认值)	wrap-reverse	
justify-content:flex-start(默认值) flex-end center space-around  space-between
align-items:stretch(默认值) flex-start flex-end center  baseline	
align-content:多行的对齐，单行无作用 stretch(默认值) flex-start flex-end center space-around  space-between 

项目属性
align-self设置具体的项目，覆盖align-items flex-start flex-end center stretch baseline	

order:0->n 优先级变小

flex
flex-grow：0(默认值,不放大)  数值越大，放大
flex-shink：1(默认值，空间不足缩小)  
flex-basis在分配多余空间之前，项目占据的主轴空间


响应式布局
	自适应布局+流式布局，位置和大小都会改变
```

两种盒子模型
``` 
盒子总宽高: content+padding+boder+margin
内容宽高：
  标准盒子模型： width=content   元素padding,magin,boder单独计算
  ie盒子模型： width=content+padding+boder  

切换 box-sizing:content-box(默认值)  boder-box
```

link和@import的区别
```
link:兼容性好，link标签引入的 CSS 被同时加载，可以定义其他属性；
import：只能加载css，不兼容老版本浏览器，@import引入的 CSS 将在页面加载完毕后被加载。
```

csshock
```
多浏览器兼容
在css样式中加入一些特殊的符号不同浏览器势必为不同的符号(比如：_ *只有ie识别)
是一种不推荐的兼容方案
```

盒模型display:none，visibility:hidden和opcatity:0的区别
```
none：脱离文档流，不能触发事件，且不会被继承
hidden：不能触发事件，可以继承
0:可触发绑定事件，可以继承
```

行内元素，行内块元素，块元素
```
行内元素(内联元素):设置宽高无效，可以设置水平magin和垂直水平padding，默认高宽是自身内容高宽，不能放块标签
a label span
例外：a可以放除a外的标签

行内块元素:能设置宽高，其余和行内元素相同
img input button td select textarea

块元素:独占一行，不设置宽高默认情况为父元素的宽度，高度为0
例外：p,h不能放块标签

```

margin塌陷
```
同一个BFC的相邻box发生margin重叠
父子嵌套元素在垂直方向的margin,他们两个同方向的margin会取较大值.
正常情况下,父级元素应该相对浏览器进行定位,子级相对父级定位.
但由于margin的塌陷,当子级magin大于父级会带着一起运动
解决,父元素添加:
(创建BFC：块级格式化上下文，其中的元素布局是不受外界影响，bfc区域与float不会重合，float也能撑起bfc的高度)
(1)position:absolute/fixed
(2)display:inline-block/inline-grid/inline-table/
table-caption/table-cellflex/table/grid
(3)float:left/right
(4)overflow:hidden/auto/scroll

magin合并：
块级元素的垂直外边距会互相合并，也就是会以他们之间外边距大的为准
解决：
将一边的边距设为两边距之和

```

浮动(高度)塌陷 清除浮动
```
原因：在文档流中，父元素的高度默认是被子元素撑开的
子元素设置浮动以后，子元素脱离文档流，子元素无法撑起父元素的高度，且此时父元素未设置高度，导致父元素的高度塌陷
由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，造成布局错位

clear:both
overflow:hidden
父级元素添加高度
```

选择器优先级
```
!important
内联样式 
id 选择器 
伪类选择器 link hover visited :first-child:last-child  nth_child  类选择器 属性选择器[attribute]
伪元素 before after  元素(标签)选择器 
关系选择器+ >  统配选择器 * 
继承
默认
```

水平垂直居中
```
父元素添加：
单行文本：line-height:hegiht text-align:center
多行文本：display:table-cell vertival-align:middle text-align:center
图片：父元素添加display：table-cell vertical-align: middle  text-align: center

PC端有兼容性要求，宽高固定，子元素添加：
	absolute;top,left:50%;   	 magin-left,magin-top:- (元素50%宽高)
	absolute;top,left,right,bottom:num(一般设置0)   magin:auto
	absolute;top,left:50%; transform:translate(-50%,-50%)


PC端无兼容性要求，推荐flex
移动端推荐使用flex
    justify-content: center;
    align-items: center;	

grid
    align-self: center;
    justify-self: center;
```
<img src="/img/pos.PNG">

回流(重排)和重绘
```
回流：当render tree中尺寸，布局，隐藏等改变需要重新构建render tree。这就称为回流(reflow)。  回流必重绘
重绘：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的
```

精灵图(雪碧图)
```
很多的小图片合并到一张较大的图片里,使用是显示大图的特定位置和大小
缺点:维护麻烦，容易出现断裂
```

<div id="jss" ></div>

## js 

JS对象常用方法
```
valueOf()所有对象隐式调用

数组：fill[value,start,end) slice[) splice[第a个元素前,删除b个,添加元素]
join(指定分隔符默认,) pop() push() reverse() sort() unshift shift concat indexOf() lastIndexOf() 
includes() isArray() toString()  from() 

filter() find() findIndex() every() some() reduceRight() reduce() 
map() foreach(function(currentValue,index,arr))不能链式使用，无返回值，速度快，可以改变原数组 

字符串:split(指定分隔符 可使用正则表达式 ,指定返回数组length,满足条件返回)  match匹配值,多次匹配依赖g 
replace可匹配多个值,默认匹配一次依赖g repalceAll() search匹配单个下标，无值返回-1 
trim()去除两边空字符 substr[截取下标a，获取字符b个] substring[)=slice  charAt(n)返回指定位置字符
startWith()判断是否以指定字符串开始 trim()去除两边空白字符

数学：random() ceil()上舍入 floor()下舍入 round()四舍五入 pow(x，y)x的y次方 min() max() abs()

数字方法：toPrecision()返回位数 toFixed()返回小数点后指定位数 

全局：Number() String(obj) parseInt() parseFloat() isNaN()数字返回false,非数true Number()  eval()
escape()编码 unescape()解码 仅不会对数字，ascii编解码，不用于URI,一般用于字符串编解码 decodeURI()解码 encodeURI()编码 

Object:create(a,b)只能获得a本身的属性，不能读取a的原型 defineProperties(a,b)a对象上定义新的属性，或者修改现有属性 getOwnPropertyDescriptor getOwnPropertyDescriptors
Object.defineProperty(obj,name,descriptor)  hasOwnProperty()是否具有指定的属性 A.isPrototypeOf(B)B是否存在于A的原型链上	 Object.prototype.isPrototypeOf(Array)
freeze()对象永远是不可变  isFrozen() preventExtensions()可修改，删除现有属性，不能添加新属性 isExtensible() getOwnPropertyNames()指定对象的所有自身属性的属性名组成的数组
```

window对象
```
innerWidth innerHeight outWidth outHeight包含工具栏，滚动栏
pageXOffset pageYOffset页面左上角滚动栏卷走的px
screenX screenY screenLeft screenTop窗口相对屏幕的坐标
sessionStorage localStorage.setItem(a,b) getItem(a) removeItem(a)
confirm带有确认，取消提示框 alert prompt()可输入提示框
clearInterval clearTimeout setTimeout setInterval	open(url,name打开方式) close 
getComputedStyle()仅支持读，读取样式是最终样式  getSelection()获得选中内容
matchMedia(查询字符串) .matches媒体查询 addListener(fn)经停监听媒体查询变化 	removeListener(fn)
moveBy()移动指定坐标 moveTo()  resizeBy() resizeTo() scrollBy() scrollTo() 
print()打印 stop()停止加载
跨源通信otherWindow.postMessage(data, [],transfer)otherWindow其他窗口引用：
window.open窗口对象、iframe的contentWindow属性，data将要发送的数据,[]指定窗口url，transfer对象所有权转移给接收方

location:hash返回#后  host hostname返回主机和端口  href返回url search返回查询部分
assign()载入新文档 reload()重载页面 replace()替换页面，不可返回前一个页面
```

(window).document对象
```
select() 
执行一个当前文档，当前选择或者给出范围的命令execCommand("Copy")

addEventListener() removeEventListener()
anchors返回当前页面锚节点数组，必须包含name属性才会加入数组
baseURI domain返回域名  URL=location.href title cookie() lastModified最后一次修改
open() close() write() writeIn()

creatAttribute()属性节点 creatComment()注释节点 createElement()元素节点  creatDocumentFragment()虚拟对象节点 createTextNode()文本节点
getAttribute()返回属性值 getAttributeNode()返回属性节点  
hasAttribute()判断存在指定属性 hasAttributes()判断存在属性 hasChildNodes()判断存在子节点
removeAttribute(name) removeAttributeNode() removeChild() replaceChild(new,old) setAttribute(name,value) setAttributeNode()
  
appendChild()添加到最后的子节点 insertBefore(newNode,oldNode)添加到老节点之前
attributes属性集合 childNodes子节点(所有类型)集合 children子元素节点集合 parentNode firstChild lastChild cloneNode(true克隆子孙节点) 
nextSibling返回下一个同级节点 nextElementSibling只返回元素节点 
previousSibling前一个同级节点 previousElementSibling只返回元素节点 
a.isEqualNode(b)ab两个节点相等 a.isSameNode(b)ab同一个节点

querySelector() querySelectorAll()用css选择器，性能更差  getElementBy()
contentEdiable  isContentEdiable nodeName className id
value属性值 innerHTML()所有节点 textContent()获取文本节点 nodeValue()对属性、注释、文本节点有效

attributes属性集合：name value length
```

ES6新特性
```
解构赋值 let[a,b,c]=[56,56,6]
字符串扩展
	双字节	'\uxxxx'  \u0000~\uFFFF
	完整unicode	'\u{}' 

数组扩展 flat(n)  ... 
	from将类数组对象和可遍历对象(set,map)转为数组 of将值转化为数组  for of
    键值对遍历entries() 键名遍历keys() 键值遍历values() 返回遍历器对象Iterator

遍历器Iterator：为各种数据结构(set,map,array,object)提供统一的接口,主要供for of使用
创建指针对象，调用next指向数据结构
使用场合：解构赋值 ...  for of  array.from() promise.all() promise.race()

对象扩展 属性简写：变量写在{}里面，属性名=变量名 属性值=变量值  解构赋值{...}
		方法简写：a:function(){}  a(){}
		super只能用在对象的简写方法中，指向当前对象的原型对象中，常用于类的继承

对象新方法 Object.setPrototypeOf() getPrototypeOf()	 
		  Object.is(a,b) 与===不同NaN=NaN -0!=+0
		  Object.assign(a,b,c...) 对象合并 b,c...复制到a 浅拷贝，处理数组会覆盖
   		  键值对遍历entries() 键名遍历keys() 键值遍历values() 返回数组
		  fromEntries()是Object.entries([[],[]])的逆操作，用于将一个键值对数组转为对象


map([[][]]) 键名可定义为对象，不再局限于字符串 set() get() delete() has() clear() size ，也可以直接接受数组创建
set对象 类数组对象，值不可重复，自动过滤重复元素，也可以直接接受数组创建add delete clear has size 
模块import from只读，对象可改 export default可不需要了解模块具体细节，默认加载，此时import可起任意名

类的方法定义在prototype,包括构造函数 set  get设置存取值函数	
静态方法,属性不会被实例继承，但可以被类继承，只能直接通过类调用
私有方法和属性在前面加上#，且变量无需关键词

类的继承constructor中显示写法必须先使用super，调用super后才能用this,再用this改变指向   
super作为函数使用时，super指向子类的构造函数，但代表的是父类的构造函数，只能用于构造函数
super作为对象使用时，指向父类，但this指向子类，无法调用父类的实例方法属性

父类a 子类b
b.prototype._proto_=a.prototype
b._proto_=a
因为继承实现基于setPrototypeOf=function(b.prototype,a.prototype){
b.prototype._proto_=a.prototype;
return b.prototype;	
}

可继承原生构造函数boolean() array() number() string() date() function() object()

promise,async/await,generator
指数运算符**    扩展运算符...    模板字面量``   `a+${}+b`
新类型symbol('')唯一不会产生冲突
箭头函数没有原型，this指向定义时所在的对象，并且不能改变指向
const let
```

表单
```
action 属性设置提交的服务器地址
method 属性设置提交的方式 GET(默认值)或 POST

通过 submit()提交表单时，submit 事件不会触发。因此在调用这个方法前要先做数据验证。
调用 reset()方法会像单击了重置按钮一样触发 reset 事件
form.elements[num]
表单字段属性
 disabled：布尔值，表示表单字段是否禁用。
 form：指针，指向表单字段所属的表单。这个属性是只读的。
 name：字符串，这个字段的名字。
 readOnly：布尔值，表示这个字段是否只读。
 tabIndex：数值，表示这个字段在按 Tab 键时的切换顺序。
 type：字符串，表示字段类型，如"checkbox"、"radio"等。
 value：要提交给服务器的字段值。对文件输入字段来说，这个属性是只读的，仅包含计算机上
某个文件的路径。
表单字段方法
focus()  	blur()


文本框
select()
selectionStart 		selectionEnd
setSelectionRange==slice
这两个属性包含基于 0 的数值，分别表示文本选区的起点和终点


HTMLFormElement
 acceptCharset：服务器可以接收的字符集，等价于 HTML 的 accept-charset 属性。
 action：请求的 URL，等价于 HTML 的 action 属性。
 elements：表单中所有控件的 HTMLCollection。
 enctype：请求的编码类型，等价于 HTML 的 enctype 属性。
 length：表单中控件的数量。
 method：HTTP 请求的方法类型，通常是"get"或"post"，等价于 HTML 的 method 属性。
 name：表单的名字，等价于 HTML 的 name 属性。
 reset()：把表单字段重置为各自的默认值。
 submit()：提交表单。
 target：用于发送请求和接收响应的窗口的名字，等价于 HTML 的 target 属性
```

存储
```
clear()：删除所有值；不在 Firefox 中实现。
 getItem(name)：取得给定 name 的值。
 key(index)：取得给定数值位置的名称。
 removeItem(name)：删除给定 name 的名/值对
 setItem(name, value)：设置给定 name 的值。
```

闭包，内存泄漏
```
立即执行函数(function(a,b){}(传递的参数1,2,3...))

访问函数内部变量
利用垃圾回收机制，被引用的变量不会被回收，所以会造成内存泄漏
```

作用域链，变量提升
```
变量提升优先级小于函数提升
每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链,搜索是一级一级往上搜索，一旦找到不再搜索
变量提升：使用了在下面定义的变量，把变量提升到函数顶部，但使用时变量值为undefined
函数提升:和变量提升类似，但是只有声明会被提升，函数表达式，构造不会被提升
```

js多线程 通信协议
```
new Worker(js file path)
只把耗时的操作写到worker线程里

http三次握手,只能由客户端发起，做不到主动推送信息

HTML5 WebSocket：HTML5 开始提供的全双工通讯的协议，握手阶段采用http协议，无同源限制
WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据
new WebSocket(url, [protocol] )
```

js事件循环机制，宏任务微任务
```
事件循环：
（1）同步任务在主线程上执行，形成一个执行栈（execution context stack）。
（2）子线程(任务队列)执行异步任务。异步任务(定时器,事件)按顺序放入"任务队列"中。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"。
（4）述过程会不断重复，也就是常说的Event Loop(事件循环)
宏任务：每次执行栈执行的代码就是一个宏任务，所有宏任务都是添加到任务队列，所以”任务队列又叫宏任务队列”，
这个任务队列由事件触发线程来单独维护的。  script,settimeout,setinterval
微任务：当前宏任务执行结束后立即执行的任务。 promise,async/await
process.nextTick(node.js)：在当前任务队列执行完，第一个执行，优先级高的异步任务
```

js执行顺序
```
同步任务（第一个宏任务）
微任务
执行宏任务(任务队列)中的微任务
```

解决回调地狱
```
promise  pending fullfilled rejected 状态不可逆
接收两个函数，reject()，resolve()状态改变，会继续执行后续代码,代码不会直接结束(加上return结束，后续操作放入then)
状态改变的回调函数then(resolve,reject)返回pomise对象,参数为上层promise对象返回值
catch=then(null,reject)
finally不管是什么状态都要执行，一般放在链式的最后

all([])参数必须有iterator接口，全部元素resolve,返回值为他们组成的数组，或者有一个变成reject，才会继续调用后面的方法，返回值是第一个reject
any返回第一个resolve，或者所有reject

race接受promise对象的数组，返回第一个状态改变的Promsie
allsettled所有参数都改变才结束

try当参数是同步函数时，立即执行
reject("string")创建状态为reject的promise对象
Promise.reject("a")=new Promise((resolve,reject)=>reject('a'));
resolve()创建(转换对象)状态为resolve的promise对象
Promise.resolve("a")=new Promise(resolve=>resolve('a'));

async/ await 
awiat后面非promise对象基本等于同步操作(先执行async外部的同步代码，再执行内部代码)

任意一个状态变成reject，后续代码不再执行 await	Promise.reject
解决方案
try {
await}
catch{}
```

原型链
```
指向原型__proto__ 指向原型构造函数constructor 指向函数原型对象prototype
在JavaScript中通过__proto__ 指向prototype，直到指向Object对象为止，就形成了一个原型指向的链条，称之为原型链。
当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，没有则会去原型对象中寻找,
直到找到Object对象的原型,如果在Object原型(null)中依然没有找到，则返回undefined。
```

<img src="/img/原型链.PNG">

对象继承方法
```
原型继承：不能多继承
构造函数继承call/apply:只能继承父类实例的方法，不能继承原型方法
组合继承：原型加构造继承，最常用，生成了两份实例
寄生组合继承:执行效率最高，应用面最广，实现复杂
es6的extends继承
```

bind,call,apply的区别
```
第一个参数都是this的指向对象
bind 返回值是函数,参数和call类似
call 
apply 参数是数组

```

模块化
```
模块化就是一种解决问题的方案，一个模块实现特定功能的文件

引入js脚本太多，重名，变量污染，可能存在依赖关系，需要按顺序加载
1.闭包和命名空间
2.CommonJs(服务器):require引入指定模块,module暴露内容
3.AMD和RequireJS(浏览器)
4.CMD和SeaJs
5.es6模块化：
	 export 变量名
     import * as(重命名) from src
```

防抖节流
```
用户操作会导致频繁触发事件，对dom操作，资源加载等，导致网页卡顿甚至崩溃
绑定触发高频率的事件，scroll,mousemove,resize,mousedown,keyup，希望降低触发频率
防抖：事件在n秒内执行一次，如果单位时间内又触发了事件，时间计数清零
    实时搜索，拖拽，窗口调整，页面滚动

节流：每隔n秒执行一次函数
    窗口调整，页面滚动，疯狂点击

```

深浅拷贝
```
浅拷贝：拷贝多份非数字型数据，改变一份数据，会同时改变其他数据
深拷贝：改变数据，不改变其他数据
实现:JSON.parse(JSON.stringify())   递归   forEach
for in会迭代原型链的属性
数组返回数组下标(键值)
适合对象

for of ES6新特性，只会迭代对象本身的属性
返回数组元素
适合数组
用于对象需要
Object.key(arr)(键值)
Object.values(arr)(对象值)

```

dom0级事件dom2级事件
```
0级：同一个元素绑定多个事件,只会绑定最后一个事件，只能在事件冒泡阶段触发
不支持冒泡的事件load unload scroll resize blur focus mouseleave mouseenter
取消冒泡：stopPropagation() cancelBuble=true 
绑定事件：dom.onclick
解除绑定：dom.onclick=null

2级：可以监听多个事件，只有2级DOM有完整的事件流
绑定：dom.addEventListener(type,function,false)  
解除绑定:dom.removeEventListener(type,function,false)
true：捕获阶段调用；false：冒泡阶段调用
```

事件流
```
接收事件的顺序,分为三个阶段
事件捕获阶段(从父元素传递到子元素)
处于目标阶段(绑定事件的那个元素)
事件冒泡阶段(子元素传递到父元素)
```

typeof 和instance of
```
基本数据类型：number,string,null,undefined,boolean(存放在栈内存中)
引用类型存放在堆内存中，实际上存放的是指向对象的地址
基本类型：number、boolean、string、object、null、undefined,symbol
typeof：只能表示7种类型 number、boolean、string、function、object(null返回值)、undefined,symbol
instance of：检测某个对象是不是另一个对象的实例，能判断object子类
```